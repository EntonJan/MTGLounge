<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena - MTG Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: { 
                extend: { 
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: {
                        mtg: {
                            w: '#F9F3B7', u: '#3A62B7', b: '#1E1E1E', r: '#D64242', g: '#5B9567'
                        }
                    }
                } 
            }
        }
    </script>
    <style>
        body { background-color: #111827; color: #e5e5e5; font-family: 'Inter', sans-serif; overflow: hidden; }
        .glass { background: rgba(31, 41, 55, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .glass-dark { background: rgba(17, 24, 39, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .card-shadow { box-shadow: -2px 2px 8px rgba(0,0,0,0.5); }
        .tapped { transform: rotate(90deg); transition: transform 0.2s ease; }
        .untapped { transform: rotate(0deg); transition: transform 0.2s ease; }
        
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #eab308; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .coin-spin { animation: flip 1s ease-out; }
        @keyframes flip { 0% { transform: rotateY(0); } 100% { transform: rotateY(720deg); } }
        
        @keyframes pulse-warning { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .timer-warning { animation: pulse-warning 1s ease-in-out infinite; }
        
        /* Counter Styles (NEU) */
        .counter-badge {
            position: absolute; font-size: 10px; font-weight: bold;
            width: 20px; height: 20px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); z-index: 20;
            pointer-events: none;
            border: 1px solid #fff;
        }
        .counter-plus { background-color: #22c55e; color: white; top: -5px; right: -5px; }
        .counter-minus { background-color: #ef4444; color: white; top: -5px; left: -5px; }
        .counter-loyalty { background-color: #a855f7; color: white; bottom: -5px; right: -5px; }
    </style>
</head>
<body class="h-screen w-screen bg-gray-900 overflow-hidden">

    <div id="app-root" class="h-full w-full">
        <div class="h-full flex flex-col items-center justify-center">
            <div class="loader mb-4"></div>
            <p class="text-gray-400">Connecting to Arena...</p>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDocs, deleteDoc, onSnapshot, addDoc, updateDoc, query, where } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyB2qmkKq4sYOXDd7mF-Mq1rnCWCfDAWXew",
            authDomain: "entons-game-tracker.firebaseapp.com",
            projectId: "entons-game-tracker",
            storageBucket: "entons-game-tracker.firebasestorage.app",
            messagingSenderId: "968932411080",
            appId: "1:968932411080:web:d391ffe5ecbd7852bc47fd",
            measurementId: "G-KB6JSFEPS1"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        window.db = db;
        window.auth = auth;
        window.signOut = signOut;
        window.updateProfile = updateProfile;
        window.currentUser = null;
        window.collection = collection;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.onSnapshot = onSnapshot;
        window.addDoc = addDoc;
        window.updateDoc = updateDoc;
        window.query = query;
        window.where = where;
        window.getPublicRoomCollection = () => collection(db, 'arena_rooms');

        const renderAuthCheck = () => {
             onAuthStateChanged(auth, (user) => {
                const rootElement = document.getElementById('app-root');
                if (user) {
                    window.currentUser = user;
                    
                    if (typeof App !== 'undefined') {
                        const root = ReactDOM.createRoot(rootElement);
                        root.render(React.createElement(App, { user: user })); 
                    } else {
                         setTimeout(() => {
                            if (typeof App !== 'undefined') {
                                const root = ReactDOM.createRoot(rootElement);
                                 root.render(React.createElement(App, { user: user }));
                            }
                        }, 100);
                    }
                 } else {
                    window.location.href = 'index.html';
                }
            });
        };

        window.onload = renderAuthCheck;
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const generateId = () => Math.random().toString(36).substring(2, 9);
        const ROOM_TIMEOUT_MS = 180000;

        const Header = ({ user, selectedDeck }) => {
            const displayName = user.displayName || user.email.split('@')[0];
            const hexId = user.uid.substring(0, 9).toUpperCase();

            return (
                <header className="bg-gray-800 shadow-md p-4 flex-shrink-0 border-b border-gray-700 z-50 relative">
                    <div className="max-w-7xl mx-auto flex justify-between items-center h-full">
                        <div className="flex items-center space-x-4">
                             <h1 className="text-2xl font-bold text-red-400 tracking-tight">Arena</h1>
                            <button onClick={() => window.location.href = 'homescreen.html'} className="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-full transition-colors shadow-sm" title="Home Menu">
                                <i data-lucide="home" className="w-5 h-5"></i>
                             </button>
                        </div>
                        {selectedDeck && (
                            <div className="hidden md:flex flex-col items-center absolute left-1/2 transform -translate-x-1/2">
                                 <span className="text-[10px] text-gray-500 uppercase tracking-widest font-semibold">Playing With</span>
                                 <span className="text-yellow-400 font-bold text-lg leading-none">{selectedDeck.name}</span>
                             </div>
                        )}
                        <div className="text-right text-sm">
                            <div className="flex items-center justify-end space-x-2">
                                  <span className="font-semibold text-white cursor-pointer hover:text-red-300" onClick={async () => {
                                     const newName = prompt(`Enter new display name:`);
                                     if (newName && newName.trim()) {
                                         try { await window.updateProfile(user, { displayName: newName.trim() }); window.location.reload(); } catch(e) {}
                                     }
                                 }}>{displayName}</span>
                                <span className="text-gray-500">| {hexId}</span>
                            </div>
                             <div className="flex items-center justify-end space-x-2 mt-1">
                                <span className="text-xs text-gray-500">{user.email}</span>
                                <button onClick={() => window.signOut(window.auth).then(() => window.location.href = 'index.html')} className="text-red-400 hover:text-red-300 text-xs flex items-center">
                                    <i data-lucide="log-out" className="w-3 h-3 mr-1"></i> Logout
                                 </button>
                            </div>
                        </div>
                    </div>
                 </header>
            );
        };

        const CardImage = ({ src, card, className, style, onClick, onContextMenu, onMouseEnter, onMouseLeave, isBack = false }) => {
            const imageSrc = isBack ? 'https://upload.wikimedia.org/wikipedia/en/a/aa/Magic_the_gathering-card_back.jpg' : src;
            
            // Render Counters (NEU)
            const counters = card?.counters || {};
            const plus1 = counters.plus1 || 0;
            const minus1 = counters.minus1 || 0;
            const loyalty = counters.loyalty || 0;

            return (
                <div 
                    className={`relative rounded-lg overflow-hidden bg-gray-800 ${className}`} 
                    style={style}
                    onClick={onClick}
                    onContextMenu={onContextMenu}
                    onMouseEnter={onMouseEnter}
                    onMouseLeave={onMouseLeave}
                >
                    <img src={imageSrc} alt={card?.name || 'Card'} className="w-full h-full object-cover select-none pointer-events-none" />
                    {!isBack && <div className="absolute inset-0 bg-gradient-to-tr from-transparent via-white/5 to-white/10 pointer-events-none"></div>}
                    
                    {/* Counter Badges (NEU) */}
                    {!isBack && plus1 > 0 && <div className="counter-badge counter-plus" title="+1/+1 Counter">+{plus1}</div>}
                    {!isBack && minus1 > 0 && <div className="counter-badge counter-minus" title="-1/-1 Counter">-{minus1}</div>}
                    {!isBack && loyalty > 0 && <div className="counter-badge counter-loyalty" title="Loyalty">{loyalty}</div>}
                    {!isBack && card?.pt && <div className="absolute bottom-1 right-1 bg-black/70 text-white text-[10px] px-1 rounded font-bold border border-gray-600">{card.pt}</div>}
                </div>
            );
        };

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className="bg-gray-800 border border-gray-600 rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-gray-700">
                            <h3 className="text-xl font-bold text-yellow-400">{title}</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-white">
                                <i data-lucide="x" className="w-6 h-6"></i>
                            </button>
                        </div>
                        <div className="p-4 overflow-y-auto flex-grow">
                            {children}
                        </div>
                    </div>
                </div>
            );
        };

        const ContextMenu = ({ x, y, options, onClose }) => {
            if (!options || options.length === 0) return null;
            return (
                <div className="fixed z-[200] bg-gray-800 border border-gray-600 rounded shadow-xl py-1 min-w-[180px]" style={{ left: x, top: y }} onMouseLeave={onClose} onContextMenu={e => e.preventDefault()}>
                    {options.map((opt, i) => (
                        <button key={i} onClick={(e) => { e.stopPropagation(); opt.action(); onClose(); }} className={`block w-full text-left px-4 py-2 text-sm hover:bg-gray-700 ${opt.color || 'text-white'} ${opt.label === '---' ? 'pointer-events-none' : ''}`}>
                            {opt.label === '---' ? <hr className="border-gray-700 my-1" /> : opt.label}
                        </button>
                    ))}
                </div>
            );
        };

        const Coin = () => (
            <div className="w-6 h-6 rounded-full bg-gradient-to-br from-yellow-300 to-yellow-600 border border-yellow-700 flex items-center justify-center shadow-lg coin-spin mx-2" title="Starting Player">
                <span className="text-yellow-900 font-bold text-xs">1</span>
            </div>
        );
        // --- CONSTANTS (Für Token-Erstellung) ---
        const COMMON_TOKENS = [
            { name: 'Treasure', type: 'Artifact Token', image: 'https://cards.scryfall.io/large/front/6/e/6e84d47b-83f8-41f4-90f9-81335b8f2f53.jpg', pt: null },
            { name: 'Food', type: 'Artifact Token', image: 'https://cards.scryfall.io/large/front/b/f/bf36408d-ed85-497f-8e68-d3a922c388a0.jpg', pt: null },
            { name: 'Clue', type: 'Artifact Token', image: 'https://cards.scryfall.io/large/front/0/0/0088de00-d310-4c08-a56f-e085a6791f42.jpg', pt: null },
            { name: 'Soldier', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/7/3/73c1b01c-d766-41f2-9861-12502b0cffb3.jpg', pt: '1/1' },
            { name: 'Goblin', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/b/d/bd08c2a3-f9a8-406b-a2c2-b5b155f3408c.jpg', pt: '1/1' },
            { name: 'Zombie', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/8/e/8e5e1e07-f316-43c1-8f9f-7d1a5c6ca801.jpg', pt: '2/2' },
            { name: 'Angel', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/f/e/fe261e68-0e86-444a-b14a-11e0f06795f0.jpg', pt: '4/4' },
            { name: 'Dragon', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/8/c/8c7827e8-4228-4f1b-a45e-5b12163b784a.jpg', pt: '5/5' },
            { name: 'Copy', type: 'Token', image: 'https://cards.scryfall.io/large/front/4/f/4f4931ce-18f3-4fac-b8c7-99ea78f4019a.jpg', pt: null }
        ];

        const COLOR_DATA = [
            { id: 'W', hex: '#F9F3B7', bg: 'bg-yellow-100', text: 'text-yellow-900', label: 'White' },
            { id: 'U', hex: '#3A62B7', bg: 'bg-blue-600', text: 'text-white', label: 'Blue' },
            { id: 'B', hex: '#1E1E1E', bg: 'bg-gray-900', text: 'text-white', label: 'Black' },
            { id: 'R', hex: '#D64242', bg: 'bg-red-600', text: 'text-white', label: 'Red' },
            { id: 'G', hex: '#5B9567', bg: 'bg-green-600', text: 'text-white', label: 'Green' },
            { id: 'C', hex: '#A9A9A9', bg: 'bg-gray-500', text: 'text-white', label: 'Colorless' }
        ];
        
        // --- GAME SIM COMPONENT ---
        const GameSim = ({ deck, onLeave, roomId }) => {
            const [roomState, setRoomState] = useState(null);
            const [loading, setLoading] = useState(true);
            const [viewingZone, setViewingZone] = useState(null); 
            const [draggedCard, setDraggedCard] = useState(null);
            const [hoveredCard, setHoveredCard] = useState(null);
            const [libraryMenu, setLibraryMenu] = useState(null);
            const [topCardView, setTopCardView] = useState(null);
            const [myHandMinimized, setMyHandMinimized] = useState(false);
            const [oppHandMinimized, setOppHandMinimized] = useState(false);
            
            const [leaveGameModal, setLeaveGameModal] = useState(false);
            const [gameResult, setGameResult] = useState({ winner: '', confirmed: false });
            
            // NEUE STATES FÜR TOKEN/COUNTER
            const [contextMenu, setContextMenu] = useState(null);
            const [tokenCreatorModal, setTokenCreatorModal] = useState(false);

            const playerLowerBattlefieldRef = useRef(null);
            const playerUpperBattlefieldRef = useRef(null);
            const initializingRef = useRef(false);
            const hasInitializedRef = useRef(false);

            const user = window.currentUser;
            const db = window.db;

            // Sync Room State
            useEffect(() => {
                const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                const unsubscribe = window.onSnapshot(roomRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        setRoomState(data);
                        setLoading(false);
                        
                        if (data.gameResult && !data.gameResult.confirmed && data.gameResult.submittedBy !== user.uid) {
                            setGameResult(data.gameResult);
                            setLeaveGameModal(true);
                        }
                    } else { onLeave(); }
                });
                return () => unsubscribe();
            }, [roomId]);

            // Host Logic for Random Start Player
            useEffect(() => {
                if (!loading && roomState && roomState.host === user.uid && !roomState.startingPlayer && roomState.players.length === 2) {
                    const starter = Math.random() < 0.5 ? roomState.players[0] : roomState.players[1];
                    window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), { startingPlayer: starter });
                }
            }, [roomState, loading, user.uid, roomId]);

            // Initialize Player State (mit counters: {})
            useEffect(() => {
                if (loading || !roomState) return;
                const myId = user.uid;
                if (roomState.gameState && roomState.gameState[myId]) {
                    hasInitializedRef.current = true;
                    return;
                }
                if (initializingRef.current || hasInitializedRef.current) return;

                console.log("Initializing Player...");
                initializingRef.current = true;
                
                const initLibrary = deck.cards.map(c => ({ ...c, instanceId: generateId(), isTapped: false, counters: {} }));
                for (let i = initLibrary.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [initLibrary[i], initLibrary[j]] = [initLibrary[j], initLibrary[i]];
                }
                const startingHand = initLibrary.splice(0, 7);
                const commander = deck.commander ? [{ ...deck.commander, instanceId: generateId(), isTapped: false, isCommander: true, counters: {} }] : [];

                const initialPlayerState = {
                    life: 40, commanderDamage: 0, cmdTax: 0,
                    library: initLibrary, hand: startingHand, 
                    battlefieldUpper: [], battlefieldLower: [],
                    graveyard: [], exile: [], commandZone: commander
                };

                window.setDoc(window.doc(window.getPublicRoomCollection(), roomId), {
                    gameState: { [myId]: initialPlayerState }
                }, { merge: true })
                .then(() => { hasInitializedRef.current = true; initializingRef.current = false; })
                .catch(e => { initializingRef.current = false; });
            }, [roomState, deck, loading]);

            useEffect(() => { lucide.createIcons(); }, [roomState, viewingZone, leaveGameModal, myHandMinimized, oppHandMinimized, contextMenu, tokenCreatorModal]);

            const myState = roomState?.gameState?.[user.uid];
            const opponentId = roomState?.players?.find(p => p !== user.uid);
            const opponentState = roomState?.gameState?.[opponentId];
            const opponentName = roomState?.players?.find(p => p !== user.uid) === roomState?.host ? roomState?.hostName : 'Opponent';
            const startingPlayerId = roomState?.startingPlayer;

            // Mulligan Visibility Logic
            const showMulligan = useMemo(() => {
                if (!myState) return false;
                const initialDeckSize = deck.cards.length + (deck.commander ? 1 : 0);
                const currentLibSize = myState.library.length;
                const cardsPlayed = (myState.battlefieldUpper?.length || 0) + (myState.battlefieldLower?.length || 0) + (myState.graveyard?.length || 0) + (myState.exile?.length || 0);
                const hasDrawn = (myState.hand?.length || 0) + currentLibSize < initialDeckSize;
                return !hasDrawn && cardsPlayed === 0;
            }, [myState, deck]);

            if (loading || !myState) return <div className="h-full flex flex-col items-center justify-center text-yellow-400"><div className="loader mb-4"></div><p>Syncing...</p></div>;

            const updateMyState = (updates) => {
                const updatePayload = {};
                Object.keys(updates).forEach(key => { updatePayload[`gameState.${user.uid}.${key}`] = updates[key]; });
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), updatePayload);
            };
            
            const drawCard = () => {
                if (myState.library.length === 0) return;
                const newLib = [...myState.library];
                const card = newLib.shift();
                updateMyState({ library: newLib, hand: [...myState.hand, { ...card, counters: {} }] });
            };

            const shuffleLibrary = () => {
                const newLib = [...myState.library];
                for (let i = newLib.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newLib[i], newLib[j]] = [newLib[j], newLib[i]];
                }
                updateMyState({ library: newLib });
            };

            const mulligan = () => {
                if (myState.hand.length === 0 && myState.library.length < 7) return;
                let newLib = [...myState.library, ...myState.hand];
                newLib = newLib.map(c => ({ ...c, counters: {} })); // Clear counters on mulligan
                for (let i = newLib.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newLib[i], newLib[j]] = [newLib[j], newLib[i]];
                }
                const newHand = newLib.splice(0, 7);
                updateMyState({ library: newLib, hand: newHand });
            };

            const playCard = (card, fromZone, targetBattlefield, coords = null) => {
                let x = coords?.x;
                let y = coords?.y;

                if (x === undefined || y === undefined) {
                    const bfWidth = playerLowerBattlefieldRef.current?.clientWidth || window.innerWidth;
                    const bfHeight = playerLowerBattlefieldRef.current?.clientHeight || 300;
                    x = bfWidth - 360 - (Math.random() * 50); 
                    y = (bfHeight / 2) - 60 + (Math.random() * 50); 
                }

                const newCard = { ...card, isTapped: false, x, y, counters: card.counters || {} };
                let updates = {};
                
                const bfKey = targetBattlefield === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                updates[bfKey] = [...(myState[bfKey] || []), newCard];
                
                if (fromZone === 'hand') updates.hand = myState.hand.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'command') {
                    updates.commandZone = myState.commandZone.filter(c => c.instanceId !== card.instanceId);
                    if (card.isCommander) updates.cmdTax = (myState.cmdTax || 0) + 2;
                }
                else if (fromZone === 'graveyard') updates.graveyard = myState.graveyard.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'exile') updates.exile = myState.exile.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'library_top' || fromZone === 'library') updates.library = myState.library.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'battlefieldUpper') updates.battlefieldUpper = (myState.battlefieldUpper || []).filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'battlefieldLower') updates.battlefieldLower = (myState.battlefieldLower || []).filter(c => c.instanceId !== card.instanceId);

                updateMyState(updates);
            };

            const moveCardToZone = (card, toZone) => {
                const filter = c => c.instanceId !== card.instanceId;
                let updates = {
                    battlefieldUpper: (myState.battlefieldUpper || []).filter(filter),
                    battlefieldLower: (myState.battlefieldLower || []).filter(filter),
                    hand: myState.hand.filter(filter),
                    graveyard: myState.graveyard.filter(filter),
                    exile: myState.exile.filter(filter),
                    commandZone: myState.commandZone.filter(filter),
                    library: myState.library.filter(filter)
                };
                
                const movedCard = { ...card, isTapped: false, x: undefined, y: undefined, counters: card.isCommander ? card.counters : {} };

                if (toZone === 'graveyard') updates.graveyard = [movedCard, ...updates.graveyard];
                else if (toZone === 'exile') updates.exile = [movedCard, ...updates.exile];
                else if (toZone === 'hand') updates.hand = [...updates.hand, movedCard];
                else if (toZone === 'command') {
                     updates.commandZone = [movedCard, ...updates.commandZone];
                     if (card.isCommander && card.isCommander !== movedCard.isCommander) updates.cmdTax = (myState.cmdTax || 0) + 2;
                }
                else if (toZone === 'library_top') updates.library = [movedCard, ...updates.library];
                else if (toZone === 'library_bottom') updates.library = [...updates.library, movedCard];

                updateMyState(updates);
            };

            const toggleTap = (id, battlefield) => {
                const bfKey = battlefield === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                const bf = (myState[bfKey] || []).map(c => c.instanceId === id ? { ...c, isTapped: !c.isTapped } : c);
                updateMyState({ [bfKey]: bf });
            };
            
            // NEUE LOGIK FÜR TOKENS UND COUNTER
            const createToken = (name, pt, imageUrl, colors, amount) => {
                const token = {
                    name, pt, colors,
                    image_url: imageUrl || 'https://upload.wikimedia.org/wikipedia/en/a/aa/Magic_the_gathering-card_back.jpg',
                    instanceId: generateId(),
                    isTapped: false,
                    isToken: true,
                    counters: {}
                };
                
                const bfWidth = playerLowerBattlefieldRef.current?.clientWidth || window.innerWidth;
                const bfHeight = playerLowerBattlefieldRef.current?.clientHeight || 300;
                let x = bfWidth - 360 - (Math.random() * 50); 
                let y = (bfHeight / 2) - 60 + (Math.random() * 50); 

                const newTokens = Array(amount).fill(0).map(() => ({
                    ...token,
                    instanceId: generateId(),
                    x: x + (Math.random() * 50),
                    y: y + (Math.random() * 50)
                }));
                
                updateMyState({ battlefieldLower: [...(myState.battlefieldLower || []), ...newTokens] });
                setTokenCreatorModal(false);
            };

            const adjustCounter = (cardId, battlefield, counterType, amount) => {
                const bfKey = battlefield === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                const newBf = (myState[bfKey] || []).map(c => {
                    if (c.instanceId === cardId) {
                        const newCount = Math.max(0, (c.counters?.[counterType] || 0) + amount);
                        return { 
                            ...c, 
                            counters: { ...c.counters, [counterType]: newCount },
                        };
                    }
                    return c;
                });
                updateMyState({ [bfKey]: newBf });
            };

            const handleCardContextMenu = (e, card, battlefield) => {
                e.preventDefault();
                const options = [
                    { label: 'Tap/Untap', action: () => toggleTap(card.instanceId, battlefield) },
                    { label: '---', action: () => {} },
                    { label: 'Move to Hand', action: () => moveCardToZone(card, 'hand') },
                    { label: 'Move to Graveyard', action: () => moveCardToZone(card, 'graveyard') },
                    { label: 'Move to Exile', action: () => moveCardToZone(card, 'exile') },
                    ...(card.isCommander ? [{ label: 'Move to Command Zone', action: () => moveCardToZone(card, 'command') }] : []),
                    { label: '---', action: () => {} },
                    // Counter Options
                    { label: '+1/+1 Counter (+)', action: () => adjustCounter(card.instanceId, battlefield, 'plus1', 1) },
                    { label: '+1/+1 Counter (-)', action: () => adjustCounter(card.instanceId, battlefield, 'plus1', -1), color: 'text-red-400' },
                    { label: '-1/-1 Counter (+)', action: () => adjustCounter(card.instanceId, battlefield, 'minus1', 1) },
                    { label: '-1/-1 Counter (-)', action: () => adjustCounter(card.instanceId, battlefield, 'minus1', -1), color: 'text-red-400' },
                    { label: 'Loyalty Counter (+)', action: () => adjustCounter(card.instanceId, battlefield, 'loyalty', 1) },
                    { label: 'Loyalty Counter (-)', action: () => adjustCounter(card.instanceId, battlefield, 'loyalty', -1), color: 'text-red-400' },
                    { label: '---', action: () => {} },
                    { label: 'Destroy Card', action: () => moveCardToZone(card, 'graveyard'), color: 'text-red-500' }
                ];

                setContextMenu({ x: e.clientX, y: e.clientY, options });
            };

            const TokenCreatorModal = ({ onCreateToken, onClose }) => {
                const [tab, setTab] = useState('common');
                const [name, setName] = useState('');
                const [pt, setPt] = useState('0/0');
                const [amount, setAmount] = useState(1);
                const [colors, setColors] = useState([]);
                
                const toggleColor = (colorId) => {
                    setColors(prev => prev.includes(colorId) ? prev.filter(c => c !== colorId) : [...prev, colorId]);
                };
                
                const handleCreateCustom = () => {
                    if (!name && !pt) { alert("Please enter at least a Name or P/T for the custom token."); return; }
                    const selectedColors = COLOR_DATA.filter(c => colors.includes(c.id));
                    let bgColorHex = '374151'; 
                    let textColorHex = 'ffffff'; 

                    if (selectedColors.length === 1) {
                         const colorData = selectedColors[0];
                         bgColorHex = colorData.hex.substring(1);
                         textColorHex = colorData.id === 'W' ? '1f2937' : 'ffffff';
                    } else if (selectedColors.length > 1) {
                        bgColorHex = '1e293b'; 
                        textColorHex = 'ffffff';
                    }
                    
                    const stats = pt.replace('/', ' / ');
                    const displayName = name || 'Custom Token';
                    const text = `${displayName.toUpperCase()}\n${stats}`;
                    const customImageUrl = `https://placehold.co/400x560/${bgColorHex}/${textColorHex}.png?text=${encodeURIComponent(text)}`;
                    
                    onCreateToken(name || 'Custom Token', pt, customImageUrl, colors, amount);
                };

                return (
                    <Modal isOpen={true} onClose={onClose} title="Create Token">
                        <div className="flex border-b border-gray-700 mb-4">
                            <button onClick={() => setTab('common')} className={`py-2 px-4 text-sm font-semibold transition-colors ${tab === 'common' ? 'text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400 hover:text-white'}`}> Common Tokens </button>
                            <button onClick={() => setTab('custom')} className={`py-2 px-4 text-sm font-semibold transition-colors ${tab === 'custom' ? 'text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400 hover:text-white'}`}> Custom Token </button>
                        </div>
                        
                        {tab === 'common' && (
                            <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
                                {COMMON_TOKENS.map(token => (
                                    <div key={token.name} onClick={() => onCreateToken(token.name, token.pt, token.image, [], 1)} className="cursor-pointer hover:scale-[1.03] transition-transform card-shadow relative rounded-lg overflow-hidden border border-gray-700">
                                        <CardImage src={token.image} card={{ name: token.name, pt: token.pt }} className="w-full h-auto aspect-[5/7]" />
                                        <div className="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                                            <span className="bg-yellow-500 text-black px-3 py-1 text-sm font-bold rounded">CREATE 1X</span>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                        
                        {tab === 'custom' && (
                            <div className="flex flex-col gap-4 max-w-lg mx-auto">
                                <input 
                                    type="text" 
                                    placeholder="Token Name (e.g., Cat Warrior)" 
                                    value={name}
                                    onChange={(e) => setName(e.target.value)}
                                    className="bg-gray-700 p-3 rounded text-white border border-gray-600 focus:ring-yellow-500 focus:border-yellow-500"
                                />
                                <input 
                                    type="text" 
                                    placeholder="P/T (e.g., 2/2 or * /*)" 
                                    value={pt}
                                    onChange={(e) => setPt(e.target.value)}
                                    className="bg-gray-700 p-3 rounded text-white border border-gray-600 focus:ring-yellow-500 focus:border-yellow-500"
                                />
                                <div className="flex items-center gap-4">
                                    <span className="text-gray-400">Amount:</span>
                                    <button onClick={() => setAmount(Math.max(1, amount - 1))} className="bg-gray-700 p-2 rounded text-white hover:bg-gray-600">-</button>
                                    <span className="text-lg font-bold">{amount}</span>
                                    <button onClick={() => setAmount(amount + 1)} className="bg-gray-700 p-2 rounded text-white hover:bg-gray-600">+</button>
                                </div>
                                
                                <div className="flex items-center gap-3">
                                    <span className="text-gray-400">Colors:</span>
                                    {COLOR_DATA.map(c => (
                                        <button key={c.id} onClick={() => toggleColor(c.id)} className={`w-8 h-8 rounded-full border-2 ${colors.includes(c.id) ? 'border-yellow-400 ring-4 ring-yellow-400/50' : 'border-gray-600 hover:border-white'}`} style={{ backgroundColor: c.hex }}>
                                        </button>
                                    ))}
                                </div>
                                <button onClick={handleCreateCustom} className="bg-green-600 hover:bg-green-500 text-white p-3 rounded-lg font-bold mt-4 disabled:bg-gray-600" disabled={amount < 1}>
                                    Create {amount}x Custom Token
                                </button>
                                <p className="text-xs text-gray-500 mt-2">A generic placeholder image will be generated based on the colors and P/T.</p>
                            </div>
                        )}
                    </Modal>
                );
            };

            const handleLeaveGame = () => {
                setLeaveGameModal(true);
            };

            const submitGameResult = async (winner) => {
                const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                await window.updateDoc(roomRef, {
                    gameResult: {
                        winner, submittedBy: user.uid, confirmed: false, timestamp: Date.now()
                    }
                });
            };

            const extractDeckColors = (deckData) => {
                if (!deckData || !deckData.commander) return [];
                const colorMap = { 'W': 'W', 'U': 'U', 'B': 'B', 'R': 'R', 'G': 'G' };
                const colors = [];
                const colorIdentity = deckData.commander.color_identity || [];
                colorIdentity.forEach(c => { if (colorMap[c]) colors.push(c); });
                return colors;
            };

            const saveMatchToTrackers = async (winnerId) => {
                try {
                    const myDeckColors = extractDeckColors(deck);
                    const opponentDeckData = roomState.playerDecks?.[opponentId];
                    const opponentDeckColors = extractDeckColors(opponentDeckData);
                    const myDeckName = deck.name || 'Unknown Deck';
                    const opponentDeckName = opponentDeckData?.name || 'Opponent Deck';
                    const iWon = winnerId === user.uid;
                    const matchData = {
                        ownDeckName: myDeckName, opponentDeckName: opponentDeckName,
                        gamesWon: iWon ? 2 : 0, gamesLost: iWon ? 0 : 2,
                        ownDeckColors: myDeckColors, opponentDeckColors: opponentDeckColors,
                        result: iWon ? 'Win' : 'Loss', format: 'Commander',
                        timestamp: Date.now(), user: user.uid
                    };
                    await window.addDoc(window.collection(db, 'users', user.uid, 'local_matches'), matchData);
                } catch (error) { console.error('Error saving match to trackers:', error); }
            };

            const confirmGameResult = async () => {
                const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                await window.updateDoc(roomRef, { 'gameResult.confirmed': true });
                await saveMatchToTrackers(gameResult.winner === 'draw' ? null : gameResult.winner);
                setLeaveGameModal(false);
                onLeave();
            };

            const handleDragStart = (e, card, fromZone) => setDraggedCard({ card, fromZone });
            
            const handleDropOnBattlefield = (e, targetBattlefield, battlefieldRef) => {
                e.preventDefault();
                if (!draggedCard) return;
                const rect = battlefieldRef.current.getBoundingClientRect();
                let x = e.clientX - rect.left - 45;
                let y = e.clientY - rect.top - 60;

                if (targetBattlefield === 'lower') { if (x < 240) x = 240; }
                
                const card = draggedCard.card;
                const fromZone = draggedCard.fromZone;

                if (fromZone === 'battlefieldUpper' || fromZone === 'battlefieldLower') {
                    const updates = {};
                    updates.battlefieldUpper = (myState.battlefieldUpper || []).filter(c => c.instanceId !== card.instanceId);
                    updates.battlefieldLower = (myState.battlefieldLower || []).filter(c => c.instanceId !== card.instanceId);
                    
                    const movedCard = { ...card, x, y };
                    if (targetBattlefield === 'upper') { updates.battlefieldUpper = [...updates.battlefieldUpper, movedCard]; } 
                    else { updates.battlefieldLower = [...updates.battlefieldLower, movedCard]; }
                    updateMyState(updates);
                } else {
                    playCard(card, fromZone, targetBattlefield, { x, y });
                }
                setDraggedCard(null);
            };

            const handleDropOnZone = (e, zone) => {
                e.preventDefault();
                if (!draggedCard) return;
                const target = zone === 'library' ? 'library_top' : zone;
                if (draggedCard.fromZone === target) { setDraggedCard(null); return; }
                moveCardToZone(draggedCard.card, target);
                setDraggedCard(null);
            };

            const handleDragOver = (e) => { e.preventDefault(); };

            // JSX render method (Start of Part 3)
            return (
                <div className="h-full w-full relative">
                    
                    {/* Opponent Zone (Upper Battlefield) */}
                    <div className="absolute top-0 left-0 w-full h-[30vh] bg-red-900/10 overflow-hidden">
                        <div ref={playerUpperBattlefieldRef} className="h-full w-full relative" onDrop={(e) => handleDropOnBattlefield(e, 'upper', playerUpperBattlefieldRef)} onDragOver={handleDragOver} >
                            {(myState.battlefieldUpper || []).map(card => (
                                <div key={card.instanceId} className="absolute cursor-pointer" style={{ left: card.x, top: card.y }} draggable onDragStart={(e) => handleDragStart(e, card, 'battlefieldUpper')} onContextMenu={(e) => handleCardContextMenu(e, card, 'battlefieldUpper')}>
                                    <CardImage 
                                        src={card.image_url} 
                                        card={card}
                                        className={`w-[90px] h-[120px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`}
                                        onClick={() => toggleTap(card.instanceId, 'upper')}
                                    />
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    {/* Zones (Upper Middle) */}
                    <div style={{ top: '30vh', height: '10vh' }} className="w-full absolute flex items-center justify-between px-4 z-10">
                        {/* Opponent Hand & Zones */}
                        <div className="flex flex-col items-center glass p-2 rounded-xl border border-gray-600 shadow-xl w-[200px]">
                            <h4 className="text-sm font-bold text-gray-400 mb-1">{opponentName}'s Hand</h4>
                            <div className="flex items-center gap-2">
                                <span className="text-xl font-bold">{opponentState?.hand.length || 0}</span>
                                <i data-lucide={oppHandMinimized ? 'eye-off' : 'eye'} className={`w-4 h-4 cursor-pointer ${oppHandMinimized ? 'text-red-400' : 'text-green-400'}`} onClick={() => setOppHandMinimized(!oppHandMinimized)}></i>
                            </div>
                        </div>
                        
                        {/* Opponent Other Zones (Graveyard, Exile) */}
                        <div className="flex gap-4">
                             <div className="bg-gray-700/50 rounded p-2 text-center w-20 relative border border-gray-600">
                                <h5 className="text-xs text-gray-400">Grave</h5>
                                <p className="text-lg font-bold text-gray-200">{opponentState?.graveyard.length || 0}</p>
                            </div>
                             <div className="bg-gray-700/50 rounded p-2 text-center w-20 relative border border-gray-600">
                                <h5 className="text-xs text-gray-400">Exile</h5>
                                <p className="text-lg font-bold text-gray-200">{opponentState?.exile.length || 0}</p>
                            </div>
                        </div>
                    </div>

                    {/* Middle Line / Gap */}
                    <div style={{ top: '40vh', height: '20vh' }} className="w-full absolute bg-gray-900/40 border-y border-gray-700 flex items-center justify-center z-10">
                        {/* Status / Log / Timer */}
                        <div className="flex items-center space-x-4 glass p-3 rounded-full shadow-lg">
                            <span className="text-yellow-400 font-bold text-sm">Game On</span>
                        </div>
                    </div>

                    {/* Player Zone (Lower Battlefield) */}
                    <div style={{ top: '60vh', height: '30vh' }} className="w-full absolute bg-blue-900/10 overflow-hidden">
                        <div ref={playerLowerBattlefieldRef} className="h-full w-full relative" onDrop={(e) => handleDropOnBattlefield(e, 'lower', playerLowerBattlefieldRef)} onDragOver={handleDragOver} >
                            {(myState.battlefieldLower || []).map(card => (
                                <div key={card.instanceId} className="absolute cursor-pointer" style={{ left: card.x, top: card.y }} draggable onDragStart={(e) => handleDragStart(e, card, 'battlefieldLower')} onContextMenu={(e) => handleCardContextMenu(e, card, 'battlefieldLower')}>
                                    <CardImage 
                                        src={card.image_url} 
                                        card={card}
                                        className={`w-[90px] h-[120px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`}
                                        onClick={() => toggleTap(card.instanceId, 'lower')}
                                    />
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    {/* Hand Zone (Bottom) */}
                    <div className={`fixed bottom-0 left-0 right-0 p-2 glass z-30 transition-all duration-300 ${myHandMinimized ? 'h-[40px]' : 'h-[140px]'}`}>
                        <div className="flex items-center h-full">
                            <button onClick={() => setMyHandMinimized(!myHandMinimized)} className="absolute right-4 top-[-20px] bg-gray-800 p-2 rounded-full border border-gray-700 hover:bg-gray-700 transition-colors z-40">
                                <i data-lucide={myHandMinimized ? 'chevron-up' : 'chevron-down'} className="w-4 h-4 text-white"></i>
                            </button>
                            <h4 className="absolute left-2 text-sm font-bold text-gray-400">{myState.hand.length} Cards in Hand</h4>
                            <div className={`flex gap-2 transition-opacity duration-300 overflow-x-auto scrollbar-hide ${myHandMinimized ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                                {(myState.hand || []).map(card => (
                                    <div key={card.instanceId} className="flex-shrink-0 cursor-grab" draggable onDragStart={(e) => handleDragStart(e, card, 'hand')}>
                                        <CardImage src={card.image_url} card={card} className="w-[80px] h-[110px] card-shadow" />
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* Player Left Sidebar (Life/Command/Token Button) */}
                    <div className="absolute top-1/2 transform -translate-y-1/2 left-2 z-40 w-56 flex flex-col gap-2 pointer-events-none">
                        <div className="pointer-events-auto bg-green-900/80 backdrop-blur-sm p-4 rounded-lg border border-green-500/50 flex-shrink-0 shadow-lg">
                            <div className="flex justify-between items-center mb-2">
                                <h4 className="text-green-400 text-lg font-bold">You</h4>
                                {startingPlayerId === user.uid && <Coin />}
                            </div>
                            <div className="text-white text-lg space-y-1">
                                <div className="flex items-center justify-between">
                                    <span>Life:</span>
                                    <span className="text-green-400 font-bold text-2xl">{myState.life}</span>
                                </div>
                                <div className="flex gap-1">
                                    <button onClick={() => updateMyState({ life: myState.life + 1 })} className="flex-1 bg-green-600 px-2 py-1 rounded text-xs hover:bg-green-500">+</button>
                                    <button onClick={() => updateMyState({ life: myState.life - 1 })} className="flex-1 bg-red-600 px-2 py-1 rounded text-xs hover:bg-red-500">-</button>
                                    <button onClick={() => updateMyState({ life: 40 })} className="flex-1 bg-gray-600 px-2 py-1 rounded text-xs hover:bg-gray-500">Reset</button>
                                </div>
                                <div className="flex items-center justify-between mt-2">
                                    <span>Cmd Dmg:</span>
                                    <span className="text-red-400 font-bold">{myState.commanderDamage || 0}</span>
                                </div>
                                <div className="flex gap-1">
                                    <button onClick={() => { const currentCmdDmg = myState.commanderDamage || 0; const newCmdDmg = currentCmdDmg + 1; updateMyState({ commanderDamage: newCmdDmg, life: myState.life - 1 }); }} className="flex-1 bg-red-600 px-2 py-1 rounded text-xs hover:bg-red-500">+</button>
                                    <button onClick={() => { const currentCmdDmg = myState.commanderDamage || 0; if (currentCmdDmg > 0) { updateMyState({ commanderDamage: currentCmdDmg - 1, life: myState.life + 1 }); } }} className="flex-1 bg-red-800 px-2 py-1 rounded text-xs hover:bg-red-700">-</button>
                                    <button onClick={() => updateMyState({ commanderDamage: 0 })} className="flex-1 bg-gray-600 px-2 py-1 rounded text-xs hover:bg-gray-500">Reset</button>
                                </div>
                            </div>
                            
                            {/* NEU: Create Token Button */}
                            <button onClick={() => setTokenCreatorModal(true)} className="mt-4 w-full bg-yellow-600 hover:bg-yellow-500 text-gray-900 p-2 rounded text-sm font-bold flex items-center justify-center shadow-lg">
                                <i data-lucide="plus-circle" className="w-4 h-4 mr-2"></i> Create Token
                            </button>
                            
                            <button onClick={handleLeaveGame} className="mt-2 w-full bg-gray-700 hover:bg-gray-600 text-white p-2 rounded text-xs font-bold flex items-center justify-center">
                                End Game
                            </button>
                        </div>
                        
                        {/* Player Command Zone */}
                        <div className="pointer-events-auto bg-gray-800/80 backdrop-blur-sm p-3 rounded-lg border border-gray-600 shadow-lg">
                            <h4 className="text-xs font-bold text-gray-400 mb-2">Command Zone (Tax: +{myState.cmdTax || 0})</h4>
                            <div className="flex flex-wrap gap-1">
                                {(myState.commandZone || []).map(card => (
                                    <div key={card.instanceId} className="flex-shrink-0 cursor-grab relative" draggable onDragStart={(e) => handleDragStart(e, card, 'command')}>
                                        <CardImage src={card.image_url} card={card} className="w-[50px] h-[70px] rounded-md card-shadow" />
                                        {card.isCommander && myState.cmdTax > 0 && <span className="absolute top-[-5px] right-[-5px] bg-red-600 text-white text-[10px] w-4 h-4 rounded-full flex items-center justify-center font-bold border border-white">+{myState.cmdTax}</span>}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                    
                    {/* Player Right Sidebar (Library, Grave, Exile) */}
                    <div className="absolute top-1/2 transform -translate-y-1/2 right-2 z-40 w-56 flex flex-col gap-2 pointer-events-none">
                        <div className="pointer-events-auto bg-gray-800/80 backdrop-blur-sm p-4 rounded-lg border border-gray-600 shadow-lg">
                            <h4 className="text-white text-lg font-bold mb-2">My Zones</h4>
                            <div className="flex flex-wrap gap-2 mb-3">
                                <div className="flex-1 bg-gray-700/50 rounded p-2 text-center relative hover:bg-gray-700 transition-colors cursor-pointer" onClick={() => setViewingZone('graveyard')} onDrop={(e) => handleDropOnZone(e, 'graveyard')} onDragOver={handleDragOver} >
                                    <h5 className="text-xs text-gray-400">Graveyard</h5>
                                    <p className="text-lg font-bold text-gray-200">{myState.graveyard.length}</p>
                                </div>
                                <div className="flex-1 bg-gray-700/50 rounded p-2 text-center relative hover:bg-gray-700 transition-colors cursor-pointer" onClick={() => setViewingZone('exile')} onDrop={(e) => handleDropOnZone(e, 'exile')} onDragOver={handleDragOver} >
                                    <h5 className="text-xs text-gray-400">Exile</h5>
                                    <p className="text-lg font-bold text-gray-200">{myState.exile.length}</p>
                                </div>
                            </div>
                            <div className="bg-gray-700/50 rounded p-2 text-center relative hover:bg-gray-700 transition-colors cursor-pointer" onClick={() => setLibraryMenu({ x: 0, y: 0 })} onDrop={(e) => handleDropOnZone(e, 'library')} onDragOver={handleDragOver}>
                                <h5 className="text-xs text-gray-400">Library</h5>
                                <p className="text-2xl font-bold text-yellow-400">{myState.library.length}</p>
                                {myState.library.length > 0 && <i data-lucide="book-open" className="absolute right-2 top-2 w-4 h-4 text-gray-400"></i>}
                            </div>
                            
                            {/* Draw/Shuffle/Mulligan Buttons */}
                            <div className="flex gap-2 flex-shrink-0 mt-3">
                                {showMulligan && (
                                     <button onClick={mulligan} className="flex-1 bg-red-600 hover:bg-red-500 text-white px-3 py-2 rounded text-xs font-bold shadow-lg">Mulligan</button>
                                )}
                                <button onClick={drawCard} className="flex-1 bg-blue-600 hover:bg-blue-500 text-white px-3 py-2 rounded text-xs font-bold shadow-lg">Draw</button>
                                <button onClick={shuffleLibrary} className="flex-1 bg-purple-600 hover:bg-purple-500 text-white px-3 py-2 rounded text-xs font-bold shadow-lg">Shuffle</button>
                            </div>
                        </div>
                    </div>

                    {/* Modals and Context Menus */}
                    {tokenCreatorModal && <TokenCreatorModal onCreateToken={createToken} onClose={() => setTokenCreatorModal(false)} />}
                    {contextMenu && <ContextMenu {...contextMenu} onClose={() => setContextMenu(null)} />}
                    
                    {/* Library Menu */}
                    {libraryMenu && (
                        <div className="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-[200] bg-gray-800 border border-gray-600 rounded shadow-xl py-1 w-60">
                            <h4 className="px-4 py-2 text-sm font-bold text-yellow-400 border-b border-gray-700">Library Actions</h4>
                            <button onClick={() => { setTopCardView(myState.library[0]); setLibraryMenu(null); }} className="block w-full text-left px-4 py-2 text-sm hover:bg-gray-700 text-white">View Top Card</button>
                            <button onClick={() => { drawCard(); setLibraryMenu(null); }} className="block w-full text-left px-4 py-2 text-sm hover:bg-gray-700 text-white">Draw Card</button>
                            <button onClick={() => { shuffleLibrary(); setLibraryMenu(null); }} className="block w-full text-left px-4 py-2 text-sm hover:bg-gray-700 text-white">Shuffle</button>
                            <button onClick={() => setLibraryMenu(null)} className="block w-full text-left px-4 py-2 text-sm hover:bg-gray-700 text-red-400">Close</button>
                        </div>
                    )}

                    {/* Zone Viewer Modal */}
                    {viewingZone && <Modal isOpen={true} onClose={() => setViewingZone(null)} title={`Viewing ${viewingZone.charAt(0).toUpperCase() + viewingZone.slice(1)}`}>
                        <div className="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-6 lg:grid-cols-7 gap-4">
                            {(myState[viewingZone] || []).map(card => (
                                <div key={card.instanceId} className="flex flex-col items-center group relative">
                                    <div className="cursor-pointer" draggable onDragStart={(e) => handleDragStart(e, card, viewingZone)}>
                                        <CardImage src={card.image_url} card={card} className="w-[100px] h-[140px] rounded-lg card-shadow" />
                                    </div>
                                    <div className="absolute top-0 right-0 p-1 flex flex-col gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                        <button onClick={() => { playCard(card, viewingZone, 'lower'); setViewingZone(null); }} className="bg-green-600 px-3 py-1 rounded text-xs font-bold text-white hover:bg-green-500" >Play</button>
                                        {viewingZone === 'library' && (
                                            <button onClick={() => { moveCardToZone(card, 'library_top'); setViewingZone(null); }} className="bg-yellow-600 px-3 py-1 rounded text-xs font-bold text-white hover:bg-yellow-500" >Top</button>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </Modal>}

                    {/* Top Card View Modal */}
                    {topCardView && (
                        <Modal isOpen={true} onClose={() => setTopCardView(null)} title="Top Card of Library">
                            <div className="flex flex-col items-center">
                                <CardImage src={topCardView.image_url} card={topCardView} className="w-[200px] h-[280px] rounded-lg card-shadow mb-4" />
                                <div className="flex gap-4">
                                    <button onClick={() => { playCard(topCardView, 'library', 'lower'); setTopCardView(null); }} className="bg-green-600 px-4 py-2 rounded text-white">Play</button>
                                    <button onClick={() => { drawCard(); setTopCardView(null); }} className="bg-blue-600 px-4 py-2 rounded text-white">Draw to Hand</button>
                                    <button onClick={() => { moveCardToZone(topCardView, 'library_bottom'); setTopCardView(null); }} className="bg-yellow-600 px-4 py-2 rounded text-white">Move to Bottom</button>
                                </div>
                            </div>
                        </Modal>
                    )}
                    
                    {/* End Game / Result Modal */}
                    {leaveGameModal && (
                        <Modal isOpen={true} onClose={() => setLeaveGameModal(false)} title="Game Result">
                             {!roomState?.gameResult?.submittedBy ? (
                                <div className="flex flex-col items-center gap-4">
                                     <p className="text-lg text-white">Who won the game?</p>
                                    <div className="flex gap-4">
                                         <button onClick={() => submitGameResult(user.uid)} className="bg-green-600 px-4 py-2 rounded text-white font-bold">I Won</button>
                                         <button onClick={() => submitGameResult(opponentId)} className="bg-red-600 px-4 py-2 rounded text-white font-bold">Opponent Won</button>
                                         <button onClick={() => submitGameResult('draw')} className="bg-gray-600 px-4 py-2 rounded text-white font-bold">Draw</button>
                                    </div>
                                </div>
                            ) : (
                                <div className="text-center space-y-4">
                                     <p className="text-xl font-bold text-yellow-400">Game Result Submitted!</p>
                                     <p className="text-lg text-white">Winner: <span className="text-green-400 font-bold">{gameResult.winner === user.uid ? 'You' : opponentName}</span></p>
                                     <p className="text-sm text-gray-400"> 
                                        {gameResult.confirmed ? "Result confirmed by both players. You can safely leave." : gameResult.submittedBy === user.uid ? "Waiting for opponent's confirmation." : "Opponent submitted a result. Please confirm."}
                                    </p>
                                    {gameResult.submittedBy !== user.uid && !gameResult.confirmed && (
                                         <button onClick={confirmGameResult} className="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded font-bold mt-4">Confirm Result & Save</button>
                                    )}
                                    {gameResult.confirmed && (
                                         <button onClick={onLeave} className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded font-bold mt-4">Leave Game</button>
                                    )}
                                </div>
                            )}
                        </Modal>
                    )}
                    
                     {/* Opponent Left Sidebar (Life/Command) (Overlay) */} 
                    <div className="absolute top-4 left-2 z-40 w-56 flex flex-col gap-2 pointer-events-none"> 
                        <div className="pointer-events-auto bg-red-900/80 backdrop-blur-sm p-4 rounded-lg border border-red-500/50 flex-shrink-0 shadow-lg">
                            <div className="flex justify-between items-center mb-2">
                                <h4 className="text-red-400 text-sm font-bold">Opponent</h4> 
                                {startingPlayerId === opponentId && <Coin />} 
                            </div>
                            <div className="text-white text-sm">
                                <span>Life:</span> <span className="text-red-400 font-bold ml-2">{opponentState?.life || 40}</span>
                            </div>
                            <div className="text-white text-sm">
                                <span>Cmd Dmg:</span> <span className="text-red-400 font-bold ml-2">{opponentState?.commanderDamage || 0}</span>
                            </div>
                        </div>
                    </div>

                </div>
            );
        };
        
        // Placeholder for DeckManager (to ensure file closure)
        const DeckManager = ({ user, onSelectDeck }) => {
            const [decks, setDecks] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const loadDecks = async () => { setDecks([]); setLoading(false); };
                loadDecks();
            }, []);
            
            return (
                <div className="p-8 max-w-7xl mx-auto h-full overflow-y-auto">
                    <h2 className="text-3xl font-bold text-yellow-400 mb-6 border-b border-gray-700 pb-2">Deck Manager</h2>
                    {loading ? (
                        <div className="flex items-center justify-center h-64">
                            <div className="loader"></div>
                            <p className="ml-4 text-gray-400">Loading decks...</p>
                        </div>
                    ) : decks.length > 0 ? (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            {decks.map(deck => (
                                <div key={deck.id} className="bg-gray-800 p-4 rounded-xl border border-gray-700 shadow-lg hover:border-yellow-500 transition-colors cursor-pointer" onClick={() => onSelectDeck(deck)}>
                                    <h3 className="text-xl font-bold text-white">{deck.name}</h3>
                                    <p className="text-sm text-gray-400">Commander: {deck.commander?.name || 'N/A'}</p>
                                    <p className="text-xs text-gray-500 mt-2">Cards: {deck.cards.length} + 1 Cmdr</p>
                                </div>
                            ))}
                        </div>
                    ) : (
                        <p className="text-gray-500 text-center py-8">No decks found. Please go to the Deck Builder (external link) to create one.</p>
                    )}
                    <button onClick={() => onSelectDeck('open_manager')} className="mt-6 bg-blue-600 hover:bg-blue-500 text-white p-3 rounded-lg font-bold">
                         Back to Lobby
                    </button>
                </div>
            );
        };
        
        // Placeholder for Lobby (to ensure file closure)
        const Lobby = ({ user, selectedDeck, onSelectDeck, onStartGame, onLeaveGame }) => {
             const [rooms, setRooms] = useState([]);
            const [creating, setCreating] = useState(false);
            const [loading, setLoading] = useState(true);
            const [roomName, setRoomName] = useState(`${user.displayName || user.email.split('@')[0]}'s Game`);
            
            useEffect(() => {
                const q = window.query(window.getPublicRoomCollection(), window.where('players', 'array-contains', user.uid));
                const unsubscribe = window.onSnapshot(q, (snapshot) => {
                    const roomList = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setRooms(roomList);
                    setLoading(false);
                });
                return () => unsubscribe();
            }, []);
            
            const createRoom = async () => {
                 if (!selectedDeck) { alert("Please select a deck first."); return; }
                 setCreating(true);
                 try {
                     const deckReference = { deckId: selectedDeck.id, deckName: selectedDeck.name, commander: selectedDeck.commander?.name || 'N/A' };
                     const newRoomRef = window.doc(window.getPublicRoomCollection(), window.generateId());
                     await window.setDoc(newRoomRef, {
                         host: user.uid, hostName: user.displayName || user.email.split('@')[0],
                         players: [user.uid], roomName: roomName,
                         playerDecks: { [user.uid]: deckReference }, 
                         createdAt: Date.now()
                     });
                     onStartGame(newRoomRef.id);
                 } catch (e) { alert("Error creating room: " + e.message); } finally { setCreating(false); }
            };
            
            const joinRoom = async (roomId) => {
                 if (!selectedDeck) { alert("Select a deck first"); return; }
                 try {
                     const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                     const deckReference = { deckId: selectedDeck.id, deckName: selectedDeck.name, commander: selectedDeck.commander?.name || 'N/A' };
                     await window.updateDoc(roomRef, {
                         players: window.arrayUnion(user.uid),
                         playerDecks: { [user.uid]: deckReference }
                     });
                     onStartGame(roomId);
                 } catch (e) { alert("Error joining room: " + e.message); }
            };

            const DeckCardSmall = ({ deck, onSelectDeck }) => {
                const colors = deck.commander?.color_identity || [];
                return (
                    <div onClick={() => onSelectDeck(deck)} className={`bg-gray-800 p-3 rounded-xl border-2 ${selectedDeck?.id === deck.id ? 'border-yellow-400' : 'border-gray-700 hover:border-gray-500'} transition-colors cursor-pointer shadow-lg`}>
                        <h4 className="font-bold text-white text-md truncate">{deck.name}</h4>
                        <p className="text-xs text-gray-400">Cmdr: {deck.commander?.name || 'N/A'}</p>
                        <div className="flex gap-1 mt-1">
                            {colors.map(c => <span key={c} className={`w-3 h-3 rounded-full border border-gray-900 flex items-center justify-center text-xs font-bold`} style={{ backgroundColor: COLOR_DATA.find(cd => cd.id === c)?.hex }}></span>)}
                        </div>
                    </div>
                );
            };

            return (
                 <div className="p-8 max-w-7xl mx-auto h-full overflow-y-auto">
                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div className="lg:col-span-1">
                            <h2 className="text-2xl font-bold text-yellow-400 mb-4">Your Deck</h2>
                            {selectedDeck ? (
                                <div className="bg-gray-800 p-6 rounded-xl border border-yellow-500 shadow-xl">
                                    <h3 className="text-xl font-bold text-white mb-2">{selectedDeck.name}</h3>
                                    <p className="text-sm text-gray-400">Commander: {selectedDeck.commander?.name || 'N/A'}</p>
                                    <button onClick={() => onSelectDeck('open_manager')} className="mt-4 text-yellow-400 hover:text-yellow-300 text-sm">Change Deck</button>
                                </div>
                            ) : (
                                <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-xl text-center">
                                    <p className="text-white mb-4">No deck selected.</p>
                                    <button onClick={() => onSelectDeck('open_manager')} className="bg-yellow-600 hover:bg-yellow-500 text-gray-900 p-2 rounded text-sm font-bold">
                                        Select Deck
                                    </button>
                                </div>
                            )}
                            
                            <h3 className="text-xl font-bold text-yellow-400 mt-8 mb-4">Create Game</h3>
                            <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-xl space-y-4">
                                <input type="text" value={roomName} onChange={e => setRoomName(e.target.value)} placeholder="Room Name" className="bg-gray-700 p-2 rounded w-full text-white border border-gray-600" />
                                <button onClick={createRoom} disabled={!selectedDeck || creating} className="w-full bg-green-600 hover:bg-green-500 disabled:bg-gray-600 disabled:cursor-not-allowed text-white p-3 rounded font-bold transition-colors">
                                    {creating ? 'Creating...' : 'Create Room'}
                                </button>
                                {!selectedDeck && <p className="text-red-400 text-xs mt-2">Select a deck to create a room.</p>}
                            </div>
                        </div>
                        
                        <div className="lg:col-span-2">
                             <h3 className="text-2xl font-bold text-yellow-400 mb-4">Available Rooms</h3>
                             <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-xl">
                                 {loading ? (
                                     <div className="flex justify-center py-8"><div className="loader"></div></div>
                                 ) : (
                                     <div className="space-y-4">
                                         {rooms.filter(r => r.players.length < 2).map(room => (
                                              <div key={room.id} className="flex justify-between items-center bg-gray-700 p-3 rounded-lg border border-gray-600">
                                                  <div>
                                                      <p className="font-bold text-white">{room.roomName}</p>
                                                      <p className="text-sm text-gray-400">Host: {room.hostName}</p>
                                                  </div>
                                                  {room.host !== user.uid && (
                                                       <button 
                                                           onClick={() => joinRoom(room.id)}
                                                           disabled={!selectedDeck || !!room.emptyAt}
                                                           className="bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-4 py-2 rounded"
                                                       >
                                                            {room.emptyAt ? 'Closing' : 'Join'}
                                                       </button>
                                                    )}
                                              </div>
                                         ))}
                                         {rooms.filter(r => r.players.length < 2).length === 0 && (
                                             <p className="text-gray-500 text-center py-8">No rooms available</p>
                                         )}
                                     </div>
                                 )}
                             </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        // --- APP COMPONENT ---
        const App = ({ user }) => {
            const [view, setView] = useState('lobby'); // 'lobby', 'deck_manager', 'game'
            const [selectedDeck, setSelectedDeck] = useState(null);
            const [currentRoomId, setCurrentRoomId] = useState(null);

            const handleSelectDeck = (deckOrAction) => {
                if (deckOrAction === 'open_manager') {
                    setView('deck_manager');
                } else {
                    setSelectedDeck(deckOrAction);
                    setView('lobby'); 
                }
            };

            const handleStartGame = (roomId) => {
                setCurrentRoomId(roomId);
                setView('game');
            };

            const leaveGame = () => {
                setCurrentRoomId(null);
                setView('lobby');
            };
            
            const renderContent = () => {
                if (view === 'deck_manager') {
                    return <DeckManager user={user} onSelectDeck={handleSelectDeck} />;
                }
                if (view === 'game' && currentRoomId && selectedDeck) {
                    return <GameSim deck={selectedDeck} onLeave={leaveGame} roomId={currentRoomId} />;
                }
                return <Lobby user={user} selectedDeck={selectedDeck} onSelectDeck={handleSelectDeck} onStartGame={handleStartGame} onLeaveGame={leaveGame} />;
            };
            
            return (
                <div className="h-full flex flex-col">
                    <Header user={user} selectedDeck={selectedDeck} />
                    <div className="flex-grow overflow-hidden">
                        {renderContent()}
                    </div>
                </div>
            );
        };
        
        // --- LUCIDE ICON INITIALIZATION ---
        useEffect(() => {
            lucide.createIcons();
        }, []);


    </script>
</body>
</html>
