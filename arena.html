<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena - MTG Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: { 
                extend: { 
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: {
                        mtg: {
                            w: '#F9F3B7', u: '#3A62B7', b: '#1E1E1E', r: '#D64242', g: '#5B9567'
                        }
                    }
                } 
            }
        }
    </script>
    <style>
        body { background-color: #111827; color: #e5e5e5; font-family: 'Inter', sans-serif; overflow: hidden; }
        .glass { background: rgba(31, 41, 55, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .glass-dark { background: rgba(17, 24, 39, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .card-shadow { box-shadow: -2px 2px 8px rgba(0,0,0,0.5); }
        .tapped { transform: rotate(90deg); transition: transform 0.2s ease; }
        .untapped { transform: rotate(0deg); transition: transform 0.2s ease; }
        
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #eab308; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .coin-spin { animation: flip 1s ease-out; }
        @keyframes flip { 0% { transform: rotateY(0); } 100% { transform: rotateY(720deg); } }

        @keyframes pulse-warning { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .timer-warning { animation: pulse-warning 1s ease-in-out infinite; }
        
        /* Counter Styles */
        .counter-badge {
            position: absolute; font-size: 10px; font-weight: bold;
            width: 20px; height: 20px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); z-index: 20;
            pointer-events: none;
            border: 1px solid #fff;
        }
        .counter-plus { background-color: #22c55e; color: white; top: -5px; right: -5px; }
        .counter-minus { background-color: #ef4444; color: white; top: -5px; left: -5px; }
        .counter-loyalty { background-color: #a855f7; color: white; bottom: -5px; right: -5px; }
    </style>
</head>
<body class="h-screen w-screen bg-gray-900 overflow-hidden">

    <div id="app-root" class="h-full w-full">
        <div class="h-full flex flex-col items-center justify-center">
            <div class="loader mb-4"></div>
            <p class="text-gray-400">Connecting to Arena...</p>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
        // Wichtig: serverTimestamp importieren
        import { getFirestore, collection, doc, setDoc, getDocs, deleteDoc, onSnapshot, addDoc, updateDoc, query, where, FieldValue, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyB2qmkKq4sYOXDd7mF-Mq1rnCWCfDAWXew",
            authDomain: "entons-game-tracker.firebaseapp.com",
            projectId: "entons-game-tracker",
            storageBucket: "entons-game-tracker.firebasestorage.app",
            messagingSenderId: "968932411080",
            appId: "1:968932411080:web:d391ffe5ecbd7852bc47fd",
            measurementId: "G-KB6JSFEPS1"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        window.db = db;
        window.auth = auth;
        window.signOut = signOut;
        window.updateProfile = updateProfile;
        window.currentUser = null;
        window.collection = collection;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.onSnapshot = onSnapshot;
        window.addDoc = addDoc;
        window.updateDoc = updateDoc;
        window.query = query;
        window.where = where;
        window.serverTimestamp = serverTimestamp; // NEU: serverTimestamp globalisiert
        window.FieldValue = FieldValue;         // NEU: FieldValue globalisiert
        window.getPublicRoomCollection = () => collection(db, 'arena_rooms');

        // Die fehlerhafte window.firebase-Struktur wurde entfernt.

        const renderAuthCheck = () => {
             onAuthStateChanged(auth, (user) => {
                const rootElement = document.getElementById('app-root');
                if (user) {
                    window.currentUser = user;
                    
                    if (typeof App !== 'undefined') {
                        const root = ReactDOM.createRoot(rootElement);
                        root.render(React.createElement(App, { user: user })); 
                    } else {
                         setTimeout(() => {
                            if (typeof App !== 'undefined') {
                                const root = ReactDOM.createRoot(rootElement);
                                 root.render(React.createElement(App, { user: user }));
                            }
                        }, 100);
                    }
                 } else {
                    window.location.href = 'index.html';
                }
            });
        };

        window.onload = renderAuthCheck;
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const generateId = () => Math.random().toString(36).substring(2, 9);
        const ROOM_TIMEOUT_MS = 180000;

        // --- CONSTANTS FOR TOKENS AND COUNTERS ---
        const COMMON_TOKENS = [
            { name: 'Treasure', pt: '0/0', type: 'Artifact Token', image_url: 'https://cards.scryfall.io/large/front/6/e/6e84d47b-83f8-41f4-90f9-81335b8f2f53.jpg' },
            { name: 'Food', pt: '0/0', type: 'Artifact Token', image_url: 'https://cards.scryfall.io/large/front/b/f/bf36408d-ed85-497f-8e68-d3a922c388a0.jpg' },
            { name: 'Clue', pt: '0/0', type: 'Artifact Token', image_url: 'https://cards.scryfall.io/large/front/0/0/0088de00-d310-4c08-a56f-e085a6791f42.jpg' },
            { name: 'Soldier', pt: '1/1', type: 'Creature Token', image_url: 'https://cards.scryfall.io/large/front/7/3/73c1b01c-d766-41f2-9861-12502b0cffb3.jpg' },
            { name: 'Goblin', pt: '1/1', type: 'Creature Token', image_url: 'https://cards.scryfall.io/large/front/b/d/bd08c2a3-f9a8-406b-a2c2-b5b155f3408c.jpg' },
            { name: 'Zombie', pt: '2/2', type: 'Creature Token', image_url: 'https://cards.scryfall.io/large/front/8/e/8e5e1e07-f316-43c1-8f9f-7d1a5c6ca801.jpg' },
            { name: 'Angel', pt: '4/4', type: 'Creature Token', image_url: 'https://cards.scryfall.io/large/front/f/e/fe261e68-0e86-444a-b14a-11e0f06795f0.jpg' },
            { name: 'Dragon', pt: '5/5', type: 'Creature Token', image_url: 'https://cards.scryfall.io/large/front/8/c/8c7827e8-4228-4f1b-a45e-5b12163b784a.jpg' },
            { name: 'Copy', pt: 'N/A', type: 'Token', image_url: 'https://cards.scryfall.io/large/front/4/f/4f4931ce-18f3-4fac-b8c7-99ea78f4019a.jpg' }
        ];

        const COUNTER_OPTIONS = [
             { label: '+1/+1 Counter', key: 'plus1' },
             { label: '-1/-1 Counter', key: 'minus1' },
             { label: 'Loyalty', key: 'loyalty' },
             { label: '---', key: 'divider' },
             { label: 'Tapped/Untapped', key: 'tapped' },
             { label: 'Move to Hand', key: 'hand' },
             { label: 'Move to Graveyard', key: 'graveyard' },
             { label: 'Move to Exile', key: 'exile' },
             { label: 'Destroy/Remove', key: 'destroy', color: 'text-red-400' },
        ];

        const Header = ({ user, selectedDeck }) => {
            const displayName = user.displayName || user.email.split('@')[0];
            const hexId = user.uid.substring(0, 9).toUpperCase();

            return (
                <header className="bg-gray-800 shadow-md p-4 flex-shrink-0 border-b border-gray-700 z-50 relative">
                    <div className="max-w-7xl mx-auto flex justify-between items-center h-full">
                        <div className="flex items-center space-x-4">
                             <h1 className="text-2xl font-bold text-red-400 tracking-tight">Arena</h1>
                            <button onClick={() => window.location.href = 'homescreen.html'} className="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-full transition-colors shadow-sm" title="Home Menu">
                                <i data-lucide="home" className="w-5 h-5"></i>
                             </button>
                        </div>
                        {selectedDeck && (
                            <div className="hidden md:flex flex-col items-center absolute left-1/2 transform -translate-x-1/2">
                                 <span className="text-[10px] text-gray-500 uppercase tracking-widest font-semibold">Playing With</span>
                                 <span className="text-yellow-400 font-bold text-lg leading-none">{selectedDeck.name}</span>
                             </div>
                        )}
                        <div className="text-right text-sm">
                            <div className="flex items-center justify-end space-x-2">
                                  <span className="font-semibold text-white cursor-pointer hover:text-red-300" onClick={async () => {
                                     const newName = prompt(`Enter new display name:`);
                                     if (newName && newName.trim()) {
                                         try { await window.updateProfile(user, { displayName: newName.trim() }); window.location.reload(); } catch(e) {}
                                     }
                                 }}>{displayName}</span>
                                <span className="text-gray-500">| {hexId}</span>
                            </div>
                             <div className="flex items-center justify-end space-x-2 mt-1">
                                <span className="text-xs text-gray-500">{user.email}</span>
                                <button onClick={() => window.signOut(window.auth).then(() => window.location.href = 'index.html')} className="text-red-400 hover:text-red-300 text-xs flex items-center">
                                    <i data-lucide="log-out" className="w-3 h-3 mr-1"></i> Logout
                                 </button>
                            </div>
                        </div>
                    </div>
                 </header>
            );
        };

        const CardImage = ({ src, card, className, style, onClick, onContextMenu, onMouseEnter, onMouseLeave, isBack = false }) => {
            const imageSrc = isBack ? 'https://upload.wikimedia.org/wikipedia/en/a/aa/Magic_the_gathering-card-back.jpg' : src;
            
            // Render Counters
            const counters = card?.counters || {};
            const plus1 = counters.plus1 || 0;
            const minus1 = counters.minus1 || 0;
            const loyalty = counters.loyalty || 0;

            return (
                <div 
                    className={`relative rounded-lg overflow-hidden bg-gray-800 ${className}`} 
                    style={style}
                    onClick={onClick}
                    onContextMenu={onContextMenu}
                    onMouseEnter={onMouseEnter}
                    onMouseLeave={onMouseLeave}
                >
                    <img src={imageSrc} alt={card?.name || 'Card'} className="w-full h-full object-cover select-none pointer-events-none" />
                    {!isBack && <div className="absolute inset-0 bg-gradient-to-tr from-transparent via-white/5 to-white/10 pointer-events-none"></div>}
                    
                    {/* Counter Badges */}
                    {!isBack && plus1 > 0 && <div className="counter-badge counter-plus" title="+1/+1 Counter">+{plus1}</div>}
                    {!isBack && minus1 > 0 && <div className="counter-badge counter-minus" title="-1/-1 Counter">-{minus1}</div>}
                    {!isBack && loyalty > 0 && <div className="counter-badge counter-loyalty" title="Loyalty">{loyalty}</div>}
                    {!isBack && card?.pt && <div className="absolute bottom-1 right-1 bg-black/70 text-white text-[10px] px-1 rounded font-bold border border-gray-600">{card.pt}</div>}
                </div>
            );
        };

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className="bg-gray-800 border border-gray-600 rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-gray-700">
                            <h3 className="text-xl font-bold text-yellow-400">{title}</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-white">
                                <i data-lucide="x" className="w-6 h-6"></i>
                            </button>
                        </div>
                        <div className="p-4 overflow-y-auto flex-grow">
                            {children}
                        </div>
                    </div>
                </div>
            );
        };

        const ContextMenu = ({ x, y, options, onClose }) => {
            if (!options || options.length === 0) return null;
            return (
                <div className="fixed z-[200] bg-gray-800 border border-gray-600 rounded shadow-xl py-1 min-w-[180px]" style={{ left: x, top: y }} onMouseLeave={onClose} onContextMenu={e => e.preventDefault()}>
                    {options.map((opt, i) => (
                        <button key={i} onClick={(e) => { e.stopPropagation(); opt.action(); onClose(); }} className={`block w-full text-left px-4 py-2 text-sm hover:bg-gray-700 ${opt.color || 'text-white'} ${opt.label === '---' ? 'pointer-events-none' : ''}`}>
                            {opt.label === '---' ? <hr className="border-gray-700 my-1" /> : opt.label}
                        </button>
                    ))}
                </div>
            );
        };

        const TokenModal = ({ isOpen, onClose, addToken }) => {
            const [selectedToken, setSelectedToken] = useState(COMMON_TOKENS[0]);
            const [customImageUrl, setCustomImageUrl] = useState('');
            const [customName, setCustomName] = useState('Custom Token');
            const [customPT, setCustomPT] = useState('N/A');

            const tokens = useMemo(() => [
                ...COMMON_TOKENS,
                { name: 'Copy', pt: 'N/A', type: 'Token', image_url: 'https://cards.scryfall.io/large/front/4/f/4f4931ce-18f3-4fac-b8c7-99ea78f4019a.jpg' }, // Sicherstellen, dass Copy nicht am Ende ist, falls wir 'Custom' später hinzufügen.
                { name: 'Custom', pt: 'N/A', type: 'Custom Token', image_url: '' }
            ], []);

            const handleAdd = () => {
                if (selectedToken.name === 'Custom') {
                    if (!customImageUrl) {
                        alert("Please provide a URL for the custom token image.");
                        return;
                    }
                    addToken({ 
                        ...selectedToken,
                        name: customName, 
                        pt: customPT,
                        image_url: customImageUrl 
                    });
                } else {
                    addToken(selectedToken);
                }
                onClose();
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title="Create Token / Counter">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        {/* Token Selection */}
                        <div className="flex flex-col space-y-4">
                            <h3 className="text-xl font-semibold text-white">Select Token Type</h3>
                            <div className="grid grid-cols-3 gap-3 max-h-96 overflow-y-auto scrollbar-thin">
                                {tokens.map((token) => (
                                    <div 
                                        key={token.name} 
                                        onClick={() => { setSelectedToken(token); setCustomImageUrl(token.image_url || ''); setCustomPT(token.pt || 'N/A'); setCustomName(token.name); }}
                                        className={`p-2 rounded-lg cursor-pointer transition-all border-2 ${selectedToken.name === token.name ? 'border-yellow-500 bg-gray-700' : 'border-gray-700 hover:border-gray-500'}`}
                                    >
                                        <CardImage 
                                            src={token.image_url || 'https://upload.wikimedia.org/wikipedia/en/a/aa/Magic_the_gathering-card-back.jpg'} 
                                            card={{ name: token.name, pt: token.pt }}
                                            className="w-full h-24 object-cover" 
                                        />
                                        <p className="text-sm text-center mt-1 font-medium">{token.name}</p>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Token Preview / Custom Options */}
                        <div className="flex flex-col space-y-4">
                            <h3 className="text-xl font-semibold text-white">Preview</h3>
                            <div className="flex justify-center">
                                <CardImage 
                                    src={selectedToken.name === 'Custom' ? customImageUrl || 'https://upload.wikimedia.org/wikipedia/en/a/aa/Magic_the_gathering-card-back.jpg' : selectedToken.image_url} 
                                    card={{ name: selectedToken.name === 'Custom' ? customName : selectedToken.name, pt: selectedToken.name === 'Custom' ? customPT : selectedToken.pt }}
                                    className="w-40 h-56 card-shadow"
                                />
                            </div>

                            {selectedToken.name === 'Custom' && (
                                <div className="space-y-3 p-4 bg-gray-700 rounded-lg">
                                    <h4 className="text-lg font-bold text-yellow-400">Custom Details</h4>
                                    <input 
                                        type="text" 
                                        value={customName} 
                                        onChange={e => setCustomName(e.target.value)}
                                        placeholder="Token Name"
                                        className="bg-gray-800 p-2 rounded w-full text-white border border-gray-600"
                                    />
                                    <input 
                                        type="text" 
                                        value={customPT} 
                                        onChange={e => setCustomPT(e.target.value)}
                                        placeholder="P/T (e.g. 1/1)"
                                        className="bg-gray-800 p-2 rounded w-full text-white border border-gray-600"
                                    />
                                    <input 
                                        type="text" 
                                        value={customImageUrl} 
                                        onChange={e => setCustomImageUrl(e.target.value)}
                                        placeholder="Image URL"
                                        className="bg-gray-800 p-2 rounded w-full text-white border border-gray-600"
                                    />
                                </div>
                            )}

                            <button onClick={handleAdd} className="mt-4 bg-green-600 hover:bg-green-500 text-white p-3 rounded-lg font-bold shadow-md">
                                Create {selectedToken.name} Token
                            </button>
                        </div>
                    </div>
                </Modal>
            );
        };
        
        const DeckCard = ({ deck, onSelect, onDelete }) => {
            const commander = deck.commander?.name || 'No Commander';
            const colors = deck.colorIdentity || [];
            
            const colorMap = {
                W: 'bg-mtg-w border-mtg-w', U: 'bg-mtg-u border-mtg-u', B: 'bg-mtg-b border-mtg-b', R: 'bg-mtg-r border-mtg-r', G: 'bg-mtg-g border-mtg-g'
            };
            const textColorMap = { W: 'text-black', U: 'text-white', B: 'text-white', R: 'text-white', G: 'text-white' };

            return (
                <div className="bg-gray-800 p-4 rounded-xl border border-gray-700 hover:border-yellow-500 transition-all cursor-pointer relative shadow-lg group">
                    <div onClick={() => onSelect(deck)} className="flex flex-col h-full">
                        <div className="flex items-start justify-between">
                            <h4 className="text-lg font-bold text-white group-hover:text-yellow-400 transition-colors leading-tight pr-8">{deck.name}</h4>
                            <button onClick={(e) => { e.stopPropagation(); onDelete(deck.id); }} className="absolute top-2 right-2 text-red-400 hover:text-red-300 transition-colors p-1 rounded-full bg-gray-700/50">
                                <i data-lucide="trash-2" className="w-4 h-4"></i>
                            </button>
                        </div>
                        <p className="text-sm text-gray-400 mt-1">Commander: {commander}</p>
                        <p className="text-xs text-gray-500 mt-0.5">{deck.cards.length} cards</p>

                        <div className="flex mt-3 space-x-1">
                            {colors.map(color => (
                                <span key={color} className={`w-4 h-4 rounded-full border-2 ${colorMap[color]} ${textColorMap[color]} flex items-center justify-center text-[10px] font-extrabold shadow`}>
                                    {color}
                                </span>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };
        
        const DeckManager = ({ user, onSelectDeck }) => {
            const [decks, setDecks] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const decksCollection = window.collection(window.db, `users/${user.uid}/decks`);
                const unsubscribe = window.onSnapshot(decksCollection, (snapshot) => {
                    const deckList = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setDecks(deckList);
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching decks:", error);
                    setLoading(false);
                });

                return () => unsubscribe();
            }, [user.uid]);

            const handleDeleteDeck = async (deckId) => {
                if (window.confirm("Are you sure you want to delete this deck? This cannot be undone.")) {
                    try {
                        const deckRef = window.doc(window.db, `users/${user.uid}/decks`, deckId);
                        await window.deleteDoc(deckRef);
                    } catch(e) {
                        alert("Failed to delete deck: " + e.message);
                    }
                }
            };

            if (loading) {
                return (
                    <div className="flex-grow flex items-center justify-center">
                        <div className="loader"></div>
                        <p className="ml-3 text-gray-400">Loading Decks...</p>
                    </div>
                );
            }

            return (
                <div className="flex-grow overflow-y-auto p-6 scrollbar-thin">
                    <div className="max-w-7xl mx-auto">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-3xl font-extrabold text-white">Deck Manager</h2>
                            <button onClick={() => window.location.href = 'builder.html'} className="bg-yellow-500 hover:bg-yellow-400 text-black p-3 rounded-lg font-bold flex items-center shadow-lg">
                                <i data-lucide="pen-tool" className="w-5 h-5 mr-2"></i> Open Deck Builder
                            </button>
                        </div>

                        {decks.length > 0 ? (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                                {decks.map(deck => (
                                    <DeckCard 
                                        key={deck.id} 
                                        deck={deck} 
                                        onSelect={onSelectDeck} 
                                        onDelete={handleDeleteDeck}
                                    />
                                ))}
                            </div>
                        ) : (
                            <div className="bg-gray-800 p-8 rounded-xl border border-gray-700 text-center">
                                <p className="text-gray-400 text-lg">No decks found. Please use the Deck Builder to create one.</p>
                                <button onClick={() => window.location.href = 'builder.html'} className="mt-4 bg-yellow-500 hover:bg-yellow-400 text-black p-2 rounded font-bold">
                                    Go to Deck Builder
                                </button>
                            </div>
                        )}
                        
                        <button onClick={() => onSelectDeck('close_manager')} className="mt-6 bg-blue-600 hover:bg-blue-500 text-white p-3 rounded-lg font-bold"> Back to Lobby </button>
                    </div>
                </div>
            );
        };

        const Lobby = ({ user, selectedDeck, onSelectDeck, onStartGame, onLeaveGame }) => { 
            const [rooms, setRooms] = useState([]);
            const [creating, setCreating] = useState(false);
            const [loading, setLoading] = useState(true);
            const [roomName, setRoomName] = useState(`${user.displayName || user.email.split('@')[0]}'s Game`);
            const [error, setError] = useState(null);

            useEffect(() => {
                const roomsCollection = window.getPublicRoomCollection();
                const q = window.query(roomsCollection, window.where('active', '==', true));
                
                const unsubscribe = window.onSnapshot(q, (snapshot) => {
                    const roomList = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    
                    const now = Date.now();
                    const freshRooms = roomList.filter(room => !room.emptyAt || (now - (room.emptyAt.toMillis ? room.emptyAt.toMillis() : room.emptyAt.seconds * 1000) < ROOM_TIMEOUT_MS));

                    setRooms(freshRooms.sort((a, b) => (b.players?.length || 0) - (a.players?.length || 0)));
                    setLoading(false);
                }, (err) => {
                    console.error("Error fetching rooms:", err);
                    setError("Failed to load rooms.");
                    setLoading(false);
                });

                return () => unsubscribe();
            }, []);

            const createRoom = async () => {
                if (!selectedDeck) {
                    setError("Please select a deck first.");
                    return;
                }
                setCreating(true);
                setError(null);
                try {
                    const newRoomRef = await window.addDoc(window.getPublicRoomCollection(), {
                        name: roomName || 'Untitled Game',
                        host: user.uid,
                        players: [user.uid],
                        active: true,
                        // FIX: Nutzt jetzt window.serverTimestamp()
                        createdAt: window.serverTimestamp(),
                        lastActive: window.serverTimestamp(),
                        gameState: {}
                    });
                    
                    onStartGame(newRoomRef.id);
                } catch (e) {
                    console.error("Error creating room:", e);
                    setError("Failed to create room: " + e.message); // Detailliertere Fehlermeldung
                } finally {
                    setCreating(false);
                }
            };

            const joinRoom = async (roomId) => {
                if (!selectedDeck) {
                    setError("Please select a deck first.");
                    return;
                }
                setError(null);
                try {
                    const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                    await window.updateDoc(roomRef, {
                        // FIX: Nutzt jetzt window.FieldValue.arrayUnion
                        players: window.FieldValue.arrayUnion(user.uid),
                        lastActive: window.serverTimestamp()
                    });
                    
                    onStartGame(roomId);
                } catch (e) {
                    console.error("Error joining room:", e);
                    setError("Failed to join room.");
                }
            };

            const leaveRoom = async (roomId) => {
                try {
                    const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                    await window.updateDoc(roomRef, {
                        // FIX: Nutzt jetzt window.FieldValue.arrayRemove
                        players: window.FieldValue.arrayRemove(user.uid),
                        emptyAt: window.serverTimestamp()
                    });
                } catch(e) {
                    console.error("Error leaving room:", e);
                }
            };

            const userRooms = rooms.filter(r => r.players.includes(user.uid));
            // Wir filtern jetzt nach Räumen mit weniger als 2 Spielern und die nicht gerade schließen
            const availableRooms = rooms.filter(r => !r.players.includes(user.uid) && r.players.length < 2 && !r.emptyAt);

            return (
                <div className="flex-grow overflow-y-auto p-6 scrollbar-thin">
                    <div className="max-w-7xl mx-auto">
                        <div className="flex flex-col lg:flex-row gap-6">
                            
                            <div className="lg:w-1/3 flex flex-col space-y-6">
                                <div className="glass p-6 rounded-xl shadow-xl border-t-4 border-yellow-500 flex flex-col">
                                    <h2 className="text-2xl font-bold text-white mb-4">Your Deck</h2>
                                    
                                    {selectedDeck ? (
                                        <div className="bg-gray-700/50 p-4 rounded-lg border border-gray-600">
                                            <h3 className="text-xl font-bold text-yellow-400 mb-1">{selectedDeck.name}</h3>
                                            <p className="text-sm text-gray-400">Commander: {selectedDeck.commander?.name || 'N/A'}</p>
                                            <p className="text-xs text-gray-500 mt-1">{selectedDeck.cards.length} cards</p>
                                            <button onClick={() => onSelectDeck('open_manager')} className="mt-3 text-yellow-400 hover:text-yellow-300 text-sm font-semibold flex items-center">
                                                <i data-lucide="switch-square" className="w-4 h-4 mr-1"></i> Change Deck
                                            </button>
                                        </div>
                                    ) : (
                                        <div className="text-center p-4">
                                            <p className="text-gray-400 mb-3">No deck selected.</p>
                                            <button onClick={() => onSelectDeck('open_manager')} className="bg-green-600 hover:bg-green-500 text-white p-3 rounded-lg font-bold shadow-md">
                                                <i data-lucide="plus" className="w-5 h-5 mr-2"></i> Select Deck
                                            </button>
                                        </div>
                                    )}
                                </div>
                                
                                <div className="glass p-6 rounded-xl shadow-xl flex flex-col">
                                    <h2 className="text-2xl font-bold text-white mb-4">Create New Game</h2>
                                    
                                    <input 
                                        type="text" 
                                        value={roomName} 
                                        onChange={e => setRoomName(e.target.value)}
                                        placeholder="Room Name"
                                        className="bg-gray-700 p-3 rounded text-white border border-gray-600 focus:ring-yellow-500 focus:border-yellow-500"
                                    />
                                    
                                    <button 
                                        onClick={createRoom} 
                                        disabled={!selectedDeck || creating}
                                        className="mt-4 bg-red-600 hover:bg-red-500 disabled:bg-gray-600 disabled:cursor-not-allowed text-white p-3 rounded-lg font-bold shadow-md flex items-center justify-center transition-colors"
                                    >
                                        {creating ? (
                                            <>
                                                <div className="loader mr-2"></div> Creating...
                                            </>
                                        ) : (
                                            <>
                                                <i data-lucide="swords" className="w-5 h-5 mr-2"></i> Create Game
                                            </>
                                        )}
                                    </button>
                                    
                                    {error && <p className="text-red-400 text-sm mt-3 text-center">{error}</p>}
                                </div>
                            </div>
                            
                            <div className="lg:w-2/3">
                                <div className="glass p-6 rounded-xl shadow-xl border-t-4 border-blue-500">
                                    <h2 className="text-2xl font-bold text-white mb-4">Active Games ({availableRooms.length})</h2>
                                    
                                    {loading && <p className="text-gray-400 text-center py-8"><span className="loader mr-2"></span> Loading rooms...</p>}
                                    
                                    <div className="space-y-3">
                                        {userRooms.map(room => (
                                            <div key={room.id} className="bg-gray-700/50 p-3 rounded-lg flex justify-between items-center border border-yellow-500">
                                                <div>
                                                    <p className="text-white font-semibold">{room.name}</p>
                                                    <p className="text-xs text-yellow-400 flex items-center">
                                                        <i data-lucide="user-check" className="w-3 h-3 mr-1"></i> Already in room ({room.players.length}/2)
                                                    </p>
                                                </div>
                                                <button 
                                                    onClick={() => onStartGame(room.id)}
                                                    className="bg-yellow-600 hover:bg-yellow-500 text-black px-4 py-2 rounded"
                                                >
                                                    Re-Join
                                                </button>
                                                <button 
                                                    onClick={() => leaveRoom(room.id)}
                                                    className="bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded ml-2"
                                                >
                                                    Leave
                                                </button>
                                            </div>
                                        ))}

                                        {availableRooms.map(room => (
                                            <div key={room.id} className="bg-gray-700/50 p-3 rounded-lg flex justify-between items-center border border-gray-600">
                                                <div>
                                                    <p className="text-white font-semibold">{room.name}</p>
                                                    <p className="text-xs text-gray-400">{room.players.length}/2 players</p>
                                                </div>
                                                <div>
                                                     {room.emptyAt ? (
                                                         <button disabled className="bg-gray-600 text-white px-4 py-2 rounded">Closing</button>
                                                     ) : (
                                                         <button 
                                                            onClick={() => joinRoom(room.id)}
                                                            disabled={!selectedDeck}
                                                            className="bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-4 py-2 rounded"
                                                        >
                                                             Join
                                                         </button>
                                                     )}
                                                </div>
                                            </div>
                                        ))}
                                        {availableRooms.length === 0 && userRooms.length === 0 && !loading && (
                                             <p className="text-gray-500 text-center py-8">No rooms available</p>
                                        )}
                                     </div>
                                </div>
                            </div>
                        </div>
                     </div>
                </div>
            );
        };

        const GameSim = ({ deck, onLeave, roomId }) => {
            const [roomState, setRoomState] = useState(null);
            const [loading, setLoading] = useState(true);
            const [opponentMaximized, setOpponentMaximized] = useState(false);
            const [viewingZone, setViewingZone] = useState(null); 
            const [draggedCard, setDraggedCard] = useState(null);
            const [contextMenu, setContextMenu] = useState(null);
            const [hoveredCard, setHoveredCard] = useState(null);
            const [topCardView, setTopCardView] = useState(null);
            const [leaveGameModal, setLeaveGameModal] = useState(false);
            const [tokenModalOpen, setTokenModalOpen] = useState(false);
            
            const playerUpperBattlefieldRef = useRef(null);
            const playerLowerBattlefieldRef = useRef(null);
            const hasInitializedRef = useRef(false);
            const initializingRef = useRef(false);

            const myId = window.currentUser.uid;
            const opponentId = roomState?.players?.find(id => id !== myId);
            const myState = roomState?.gameState?.[myId];
            const opponentState = roomState?.gameState?.[opponentId];
            const startingPlayerId = roomState?.startingPlayer;
            const gameResult = roomState?.gameResult;
            
            // --- Helper Functions (Mock implementations for functionality) ---

            const updateMyState = (updates) => {
                 const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                 window.updateDoc(roomRef, { 
                     [`gameState.${myId}`]: { 
                         ...myState, 
                         ...updates 
                     } 
                 }).catch(e => console.error("Error updating state:", e));
            };

            const findCardInZone = (cardId, zone) => {
                const zoneArray = myState[zone] || [];
                const card = zoneArray.find(c => c.instanceId === cardId);
                const cardIndex = zoneArray.findIndex(c => c.instanceId === cardId);
                return { card, cardIndex, zoneArray };
            };

            const moveCardToZone = (card, fromZone, toZone) => {
                const { card: cardToMove, cardIndex, zoneArray } = findCardInZone(card.instanceId, fromZone);
                if (!cardToMove) return;

                const newFromZone = zoneArray.filter((_, i) => i !== cardIndex);
                let newToZone = [...(myState[toZone] || [])];
                
                let newCard = { ...cardToMove, isTapped: false, x: undefined, y: undefined, counters: {} }; 
                
                if (toZone === 'library_top') {
                    newToZone = [newCard, ...newToZone];
                    toZone = 'library';
                } else if (toZone === 'library_bottom') {
                    newToZone = [...newToZone, newCard];
                    toZone = 'library';
                } else if (toZone === 'library') {
                    const randomIndex = Math.floor(Math.random() * (newToZone.length + 1));
                    newToZone.splice(randomIndex, 0, newCard);
                } else {
                    newToZone.push(newCard);
                }
                
                const updates = { [fromZone]: newFromZone, [toZone]: newToZone };
                
                if (fromZone.startsWith('battlefield')) {
                    if (cardToMove.isToken) {
                         updates[fromZone] = newFromZone; 
                         delete updates[toZone]; 
                    } else {
                        updates[toZone] = newToZone;
                    }
                }

                updateMyState(updates);
            };

            const toggleCardTapped = (card) => {
                const zone = card.isCommander ? 'commandZone' : (card.x ? 'battlefieldLower' : 'battlefieldUpper');
                const { cardIndex, zoneArray } = findCardInZone(card.instanceId, zone);
                if (cardIndex === -1) return;

                const newZone = [...zoneArray];
                newZone[cardIndex] = { ...newZone[cardIndex], isTapped: !card.isTapped };
                updateMyState({ [zone]: newZone });
            };
            
            const handleDragStart = (e, card, fromZone) => setDraggedCard({ card, fromZone });
            const handleDropOnBattlefield = (e, targetBattlefield, battlefieldRef) => { /* ... */ }; // Placeholder
            const shuffle = () => { /* ... */ }; // Placeholder
            const drawCard = () => { /* ... */ }; // Placeholder

            // --- TOKEN/COUNTER LOGIC ---
            const addToken = (tokenData) => {
                const newCard = {
                    ...tokenData,
                    instanceId: generateId(),
                    isTapped: false,
                    isToken: true,
                    x: Math.random() * (playerLowerBattlefieldRef.current?.clientWidth - 100) || 50,
                    y: Math.random() * (playerLowerBattlefieldRef.current?.clientHeight - 140) || 50,
                    counters: { plus1: 0, minus1: 0, loyalty: 0 }
                };
                updateMyState({ 
                    battlefieldLower: [...(myState.battlefieldLower || []), newCard] 
                });
            };

            const updateCardCounters = (card, zone, counterKey, change) => {
                const { cardIndex, zoneArray } = findCardInZone(card.instanceId, zone);
                if (cardIndex === -1) return;
                
                const newZone = [...zoneArray];
                const newCounters = { ...(newZone[cardIndex].counters || { plus1: 0, minus1: 0, loyalty: 0 }) };
                
                newCounters[counterKey] = Math.max(0, (newCounters[counterKey] || 0) + change);

                newZone[cardIndex] = { ...newZone[cardIndex], counters: newCounters };
                updateMyState({ [zone]: newZone });
            };

            const destroyCard = (card) => {
                const zone = card.isCommander ? 'commandZone' : (card.x ? 'battlefieldLower' : 'battlefieldUpper');
                const { cardIndex, zoneArray } = findCardInZone(card.instanceId, zone);
                if (cardIndex === -1) return;

                if (card.isToken) {
                    updateMyState({ [zone]: zoneArray.filter((_, i) => i !== cardIndex) });
                } else if (card.isCommander) {
                    if (window.confirm("Move Commander to Command Zone (Yes) or Graveyard (No)?")) {
                        const newCmdTax = (myState.cmdTax || 0) + 2;
                        updateMyState({ commandZone: [{ ...card, cmdTax: newCmdTax, isTapped: false, counters: {} }], cmdTax: newCmdTax });
                    } else {
                        moveCardToZone(card, zone, 'graveyard');
                    }
                } else {
                    moveCardToZone(card, zone, 'graveyard');
                }
            };
            
            const openCardContextMenu = (e, card) => {
                e.preventDefault();
                const targetZone = card.isCommander ? 'commandZone' : (card.x ? 'battlefieldLower' : 'battlefieldUpper');
                
                const counterOptions = COUNTER_OPTIONS.filter(opt => opt.key !== 'destroy' && opt.key !== 'tapped' && opt.key !== 'hand' && opt.key !== 'graveyard' && opt.key !== 'exile').flatMap(opt => [
                    { label: `+ ${opt.label.split(' ')[0]}`, action: () => updateCardCounters(card, targetZone, opt.key, 1) },
                    { label: `- ${opt.label.split(' ')[0]}`, action: () => updateCardCounters(card, targetZone, opt.key, -1) },
                ]);

                const options = [
                    { label: card.isTapped ? 'Untap' : 'Tap', action: () => toggleCardTapped(card) },
                    { label: '---', action: () => {} },
                    ...counterOptions,
                    { label: '---', action: () => {} },
                    { label: 'To Hand', action: () => moveCardToZone(card, targetZone, 'hand') },
                    { label: 'To Graveyard', action: () => moveCardToZone(card, targetZone, 'graveyard') },
                    { label: 'To Exile', action: () => moveCardToZone(card, targetZone, 'exile') },
                    { label: 'Destroy/Remove', color: 'text-red-400', action: () => destroyCard(card) },
                ];
                
                setContextMenu({ x: e.clientX, y: e.clientY, options });
            };

            useEffect(() => {
                // Mock for game initialization and state listener
                // You will need to implement the actual Firebase listeners here.
                setLoading(false);
                setRoomState({ players: [myId], gameState: { [myId]: { life: 40, battlefieldLower: [] } } }); 
            }, [roomId]);


            if (loading || !roomState || !myState) {
                return (
                    <div className="flex-grow flex items-center justify-center">
                        <div className="loader"></div>
                        <p className="ml-3 text-gray-400">Loading Game State...</p>
                    </div>
                );
            }

            return (
                <div className="h-full w-full relative">
                    {/* Opponent Zone */}
                    <div className="absolute top-0 w-full h-1/2 bg-gray-800 border-b border-gray-700">
                        {/* Opponent Battlefield/Command/Hand... (omitted) */}
                    </div>

                    {/* Player Zone */}
                    <div className="absolute bottom-0 w-full h-1/2 bg-gray-900 flex">
                        {/* Player Battlefield (Lower) */}
                         <div ref={playerLowerBattlefieldRef} className="flex-grow relative" 
                             onDrop={(e) => handleDropOnBattlefield(e, 'lower', playerLowerBattlefieldRef)} 
                             onDragOver={(e) => e.preventDefault()}>

                            {(myState.battlefieldLower || []).map(card => (
                                <div key={card.instanceId} className="absolute cursor-pointer z-20" style={{ left: card.x, top: card.y }}
                                    draggable onDragStart={(e) => handleDragStart(e, card, 'battlefieldLower')}
                                    onClick={() => toggleCardTapped(card)}
                                    onContextMenu={(e) => openCardContextMenu(e, card)}
                                >
                                    <CardImage 
                                        src={card.image_url} 
                                        card={card}
                                        className={`w-[90px] h-[120px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`}
                                        onMouseEnter={() => setHoveredCard(card.image_url)} 
                                        onMouseLeave={() => setHoveredCard(null)} 
                                    />
                                </div>
                            ))}
                         </div>
                        
                        {/* Player Hand / Zones Sidebar */}
                        <div className="w-1/4 h-full bg-gray-800 p-2 overflow-x-auto">
                            {/* Player Hand Content (omitted) */}
                            {/* Player Zones (Library, GY, Exile) Content (omitted) */}
                            <p className="text-gray-400 text-sm">Hand: {myState.hand?.length || 0}</p>
                            <p className="text-gray-400 text-sm">Library: {myState.library?.length || 0}</p>
                        </div>

                    </div>

                    {/* Right Sidebar (Token Button) */}
                    <div className="absolute right-2 bottom-2 z-40 flex flex-col items-end space-y-2">
                        <button onClick={() => setTokenModalOpen(true)} className="bg-purple-600 hover:bg-purple-500 text-white p-3 rounded-full font-bold shadow-2xl flex items-center transition-transform transform hover:scale-105" title="Create Token">
                            <i data-lucide="gem" className="w-5 h-5"></i>
                        </button>
                    </div>

                    {/* Life/Command Zone Sidebar (omitted) */}

                    {/* Modals and Context Menu */}
                    {contextMenu && <ContextMenu {...contextMenu} onClose={() => setContextMenu(null)} />}
                    <TokenModal isOpen={tokenModalOpen} onClose={() => setTokenModalOpen(false)} addToken={addToken} />
                    {/* ... other modals ... */}
                </div>
            );
        };

        const App = ({ user }) => {
            const [selectedDeck, setSelectedDeck] = useState(null);
            const [currentRoomId, setCurrentRoomId] = useState(null);
            const [view, setView] = useState('lobby'); 

            // FIX 1: Lucide Icons einmalig nach dem ersten Render erstellen
            // Dies behebt den "Invalid hook call" Fehler, der durch den Aufruf in jedem Renderzyklus verursacht werden konnte.
            useEffect(() => {
                lucide.createIcons();
            }, []); // Leeres Array sorgt dafür, dass es nur einmal läuft.

            const handleSelectDeck = (deckOrAction) => {
                if (deckOrAction === 'open_manager') {
                    setView('deck_manager');
                } else if (deckOrAction === 'close_manager') {
                    setView('lobby');
                } else {
                    setSelectedDeck(deckOrAction);
                    setView('lobby'); 
                }
            };

            const handleStartGame = (roomId) => {
                setCurrentRoomId(roomId);
                setView('game');
            };

            const leaveGame = () => {
                setCurrentRoomId(null);
                setView('lobby');
            };
            
            const renderContent = () => {
                if (view === 'deck_manager') {
                    return <DeckManager user={user} onSelectDeck={handleSelectDeck} />;
                }
                if (view === 'game' && currentRoomId && selectedDeck) {
                    return <GameSim deck={selectedDeck} onLeave={leaveGame} roomId={currentRoomId} />;
                }
                return <Lobby user={user} selectedDeck={selectedDeck} onSelectDeck={handleSelectDeck} onStartGame={handleStartGame} onLeaveGame={leaveGame} />;
            };
            
            return (
                <div className="h-full flex flex-col">
                    <Header user={user} selectedDeck={selectedDeck} />
                    <div className="flex-grow overflow-hidden">
                        {renderContent()}
                    </div>
                </div>
            );
        };
        
        // --- LUCIDE ICON INITIALIZATION ---
        // Der fehlerhafte, doppelte Aufruf wurde entfernt.

    </script>
</body>
</html>
