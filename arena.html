<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena - MTG Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: { 
                extend: { 
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: {
                        mtg: {
                            w: '#F9F3B7', u: '#3A62B7', b: '#1E1E1E', r: '#D64242', g: '#5B9567'
                        }
                    }
                } 
            }
        }
    </script>
    <style>
        body { background-color: #111827; color: #e5e5e5; font-family: 'Inter', sans-serif; overflow: hidden; }
        .glass { background: rgba(31, 41, 55, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .glass-dark { background: rgba(17, 24, 39, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .card-shadow { box-shadow: -2px 2px 8px rgba(0,0,0,0.5); }
        .tapped { transform: rotate(90deg); transition: transform 0.2s ease; }
        .untapped { transform: rotate(0deg); transition: transform 0.2s ease; }
        
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #eab308; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .coin-spin { animation: flip 1s ease-out; }
        @keyframes flip { 0% { transform: rotateY(0); } 100% { transform: rotateY(720deg); } }
        
        @keyframes pulse-turn { 0%, 100% { box-shadow: 0 0 10px rgba(34, 197, 94, 0.5); border-color: rgba(34, 197, 94, 0.8); } 50% { box-shadow: 0 0 20px rgba(34, 197, 94, 0.8); border-color: rgba(34, 197, 94, 1); } }
        .active-turn { animation: pulse-turn 2s infinite; }

        @keyframes pulse-turn-opp { 0%, 100% { box-shadow: 0 0 10px rgba(239, 68, 68, 0.5); border-color: rgba(239, 68, 68, 0.8); } 50% { box-shadow: 0 0 20px rgba(239, 68, 68, 0.8); border-color: rgba(239, 68, 68, 1); } }
        .active-turn-opp { animation: pulse-turn-opp 2s infinite; }

        .counter-badge { text-shadow: 0 1px 2px rgba(0,0,0,0.8); box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
    </style>
</head>
<body class="h-screen w-screen bg-gray-900 overflow-hidden">

    <div id="app-root" class="h-full w-full">
        <div class="h-full flex flex-col items-center justify-center">
            <div class="loader mb-4"></div>
            <p class="text-gray-400">Connecting to Arena...</p>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDocs, deleteDoc, onSnapshot, addDoc, updateDoc, query, where } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyB2qmkKq4sYOXDd7mF-Mq1rnCWCfDAWXew",
            authDomain: "entons-game-tracker.firebaseapp.com",
            projectId: "entons-game-tracker",
            storageBucket: "entons-game-tracker.firebasestorage.app",
            messagingSenderId: "968932411080",
            appId: "1:968932411080:web:d391ffe5ecbd7852bc47fd",
            measurementId: "G-KB6JSFEPS1"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        window.db = db;
        window.auth = auth;
        window.signOut = signOut;
        window.updateProfile = updateProfile;
        window.currentUser = null;
        window.collection = collection;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.onSnapshot = onSnapshot;
        window.addDoc = addDoc;
        window.updateDoc = updateDoc;
        window.query = query;
        window.where = where;
        window.getPublicRoomCollection = () => collection(db, 'arena_rooms');

        const renderAuthCheck = () => {
             onAuthStateChanged(auth, (user) => {
                const rootElement = document.getElementById('app-root');
                if (user) {
                    window.currentUser = user;
                    if (typeof App !== 'undefined') {
                        const root = ReactDOM.createRoot(rootElement);
                        root.render(React.createElement(App, { user: user })); 
                    } else {
                        setTimeout(() => {
                            if (typeof App !== 'undefined') {
                                const root = ReactDOM.createRoot(rootElement);
                                root.render(React.createElement(App, { user: user }));
                            }
                        }, 100);
                    }
                } else {
                    window.location.href = 'index.html';
                }
            });
        };

        window.onload = renderAuthCheck;
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const generateId = () => Math.random().toString(36).substring(2, 9);
        const ROOM_TIMEOUT_MS = 180000; 

        // --- CONSTANTS WITH REAL IMAGES ---
        const COMMON_TOKENS = [
            { name: 'Treasure', type: 'Artifact Token', image: 'https://cards.scryfall.io/large/front/f/7/f707f66a-200c-448e-bf0e-52b3149e97cb.jpg' },
            { name: 'Food', type: 'Artifact Token', image: 'https://cards.scryfall.io/large/front/b/f/bf36408d-ed85-497f-8e68-d3a922c388a0.jpg' },
            { name: 'Clue', type: 'Artifact Token', image: 'https://cards.scryfall.io/large/front/5/e/5e94b238-0ef9-472e-8557-040ebdb00010.jpg' },
            { name: 'Soldier (1/1)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/6/0/6091b64b-2525-4578-8d26-614d64233fb5.jpg' },
            { name: 'Goblin (1/1)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/4/5/453b0542-f8c3-424a-8742-83508491563f.jpg' },
            { name: 'Zombie (2/2)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/b/7/b7c93603-90d1-4122-b258-a400c25a7460.jpg' },
            { name: 'Angel (4/4)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/c/3/c315eb3d-3b95-4424-8187-578912e61408.jpg' },
            { name: 'Elf Warrior (1/1)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/7/3/73b320cd-6750-482a-99fb-87063c18e1d6.jpg' },
            { name: 'Dragon (5/5)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/a/1/a1b85355-6625-45bb-b301-443905581816.jpg' },
            { name: 'Copy', type: 'Token', image: 'https://cards.scryfall.io/large/front/0/b/0b889396-857e-4171-9c60-ec73748ba42d.jpg' }
        ];

        const COUNTER_TYPES = [
            { label: '+1/+1', color: 'bg-green-600', short: '+1' },
            { label: '-1/-1', color: 'bg-red-600', short: '-1' },
            { label: 'Flying', color: 'bg-blue-500', short: 'Fly' },
            { label: 'Lifelink', color: 'bg-pink-600', short: 'Life' },
            { label: 'Trample', color: 'bg-orange-600', short: 'Trpl' },
            { label: 'Vigilance', color: 'bg-gray-500', short: 'Vigi' },
            { label: 'Haste', color: 'bg-red-500', short: 'Hst' },
            { label: 'Hexproof', color: 'bg-purple-600', short: 'Hex' },
            { label: 'Indestructible', color: 'bg-yellow-600', short: 'Ind' },
            { label: 'Shield', color: 'bg-cyan-500', short: 'Shld' }
        ];

        const COLOR_DATA = [
            { id: 'W', hex: '#F9F3B7', bg: 'bg-yellow-100', text: 'text-yellow-900', label: 'White' },
            { id: 'U', hex: '#3A62B7', bg: 'bg-blue-600', text: 'text-white', label: 'Blue' },
            { id: 'B', hex: '#1E1E1E', bg: 'bg-gray-900', text: 'text-white', label: 'Black' },
            { id: 'R', hex: '#D64242', bg: 'bg-red-600', text: 'text-white', label: 'Red' },
            { id: 'G', hex: '#5B9567', bg: 'bg-green-600', text: 'text-white', label: 'Green' }
        ];

        const Header = ({ user, selectedDeck }) => {
            const displayName = user.displayName || user.email.split('@')[0];
            const hexId = user.uid.substring(0, 9).toUpperCase();

            return (
                <header className="bg-gray-800 shadow-md p-4 flex-shrink-0 border-b border-gray-700 z-50 relative">
                    <div className="max-w-7xl mx-auto flex justify-between items-center h-full">
                        <div className="flex items-center space-x-4">
                            <h1 className="text-2xl font-bold text-red-400 tracking-tight">Arena</h1>
                            <button onClick={() => window.location.href = 'homescreen.html'} className="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-full transition-colors shadow-sm" title="Home Menu">
                                <i data-lucide="home" className="w-5 h-5"></i>
                            </button>
                        </div>
                        {selectedDeck && (
                            <div className="hidden md:flex flex-col items-center absolute left-1/2 transform -translate-x-1/2">
                                 <span className="text-[10px] text-gray-500 uppercase tracking-widest font-semibold">Playing With</span>
                                 <span className="text-yellow-400 font-bold text-lg leading-none">{selectedDeck.name}</span>
                            </div>
                        )}
                        <div className="text-right text-sm">
                            <div className="flex items-center justify-end space-x-2">
                                 <span className="font-semibold text-white cursor-pointer hover:text-red-300" onClick={async () => {
                                     const newName = prompt(`Enter new display name:`);
                                     if (newName && newName.trim()) {
                                         try { await window.updateProfile(user, { displayName: newName.trim() }); window.location.reload(); } catch(e) {}
                                     }
                                 }}>{displayName}</span>
                                 <span className="text-gray-500">| {hexId}</span>
                            </div>
                             <div className="flex items-center justify-end space-x-2 mt-1">
                                <span className="text-xs text-gray-500">{user.email}</span>
                                <button onClick={() => window.signOut(window.auth).then(() => window.location.href = 'index.html')} className="text-red-400 hover:text-red-300 text-xs flex items-center">
                                    <i data-lucide="log-out" className="w-3 h-3 mr-1"></i> Logout
                                </button>
                            </div>
                        </div>
                    </div>
                </header>
            );
        };

        const CardImage = ({ src, alt, className, style, onClick, onContextMenu, onMouseEnter, onMouseLeave, isBack = false, counters = [] }) => {
            const imageSrc = isBack ? 'https://upload.wikimedia.org/wikipedia/en/a/aa/Magic_the_gathering-card_back.jpg' : src;
            return (
                <div 
                    className={`relative rounded-lg overflow-visible bg-gray-800 ${className}`} 
                    style={style}
                    onClick={onClick}
                    onContextMenu={onContextMenu}
                    onMouseEnter={onMouseEnter}
                    onMouseLeave={onMouseLeave}
                >
                    <div className="rounded-lg overflow-hidden w-full h-full relative">
                        <img src={imageSrc} alt={alt || 'Card Back'} className="w-full h-full object-cover select-none pointer-events-none" />
                        {!isBack && <div className="absolute inset-0 bg-gradient-to-tr from-transparent via-white/5 to-white/10 pointer-events-none"></div>}
                    </div>
                    
                    {counters && counters.length > 0 && (
                        <div className="absolute -top-2 -right-2 flex flex-col items-end gap-1 z-20 pointer-events-none">
                            {counters.map((c, i) => (
                                <span key={i} className={`${c.color} text-white text-[10px] font-bold px-1.5 py-0.5 rounded-full counter-badge border border-white/20`}>
                                    {c.short}
                                </span>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className="bg-gray-800 border border-gray-600 rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-gray-700">
                            <h3 className="text-xl font-bold text-yellow-400">{title}</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-white">
                                <i data-lucide="x" className="w-6 h-6"></i>
                            </button>
                        </div>
                        <div className="p-4 overflow-y-auto flex-grow">
                            {children}
                        </div>
                    </div>
                </div>
            );
        };

        const ContextMenu = ({ x, y, options, onClose }) => {
            const style = { left: x, top: y };
            if (y > window.innerHeight - 200) { style.top = 'auto'; style.bottom = window.innerHeight - y; }
            if (x > window.innerWidth - 200) { style.left = 'auto'; style.right = window.innerWidth - x; }

            return (
                <div className="fixed z-[200] bg-gray-800 border border-gray-600 rounded shadow-xl py-1 min-w-[160px]" style={style} onMouseLeave={onClose}>
                    {options.map((opt, i) => {
                        if (opt.divider) return <div key={i} className="h-px bg-gray-700 my-1"></div>;
                        if (opt.header) return <div key={i} className="px-4 py-1 text-xs font-bold text-gray-500 uppercase">{opt.header}</div>;
                        return (
                            <button key={i} onClick={() => { opt.action(); onClose(); }} className="block w-full text-left px-4 py-2 text-sm text-white hover:bg-gray-700 flex items-center justify-between group">
                                <span>{opt.label}</span>
                                {opt.rightIcon && <span className="text-gray-400 group-hover:text-white">{opt.rightIcon}</span>}
                            </button>
                        );
                    })}
                </div>
            );
        };

        const Coin = () => (
            <div className="w-6 h-6 rounded-full bg-gradient-to-br from-yellow-300 to-yellow-600 border border-yellow-700 flex items-center justify-center shadow-lg coin-spin mx-2" title="Starting Player">
                <span className="text-yellow-900 font-bold text-xs">1</span>
            </div>
        );

        const GameSim = ({ deck, onLeave, roomId }) => {
            const [roomState, setRoomState] = useState(null);
            const [loading, setLoading] = useState(true);
            const [viewingZone, setViewingZone] = useState(null); 
            const [draggedCard, setDraggedCard] = useState(null);
            const [hoveredCard, setHoveredCard] = useState(null);
            const [libraryMenu, setLibraryMenu] = useState(null);
            const [topCardView, setTopCardView] = useState(null);
            const [myHandMinimized, setMyHandMinimized] = useState(false);
            const [oppHandMinimized, setOppHandMinimized] = useState(false);
            const [cardContextMenu, setCardContextMenu] = useState(null);
            
            // Replaced toolsMenuOpen with TokenSelectorModal logic
            const [tokenSelectorModalOpen, setTokenSelectorModalOpen] = useState(false);
            const [tokenTab, setTokenTab] = useState('common'); // 'common' or 'custom'
            const [customTokenData, setCustomTokenData] = useState({ name: '', power: '1', toughness: '1', colors: { W:false, U:false, B:false, R:false, G:false }, imageUrl: '' });

            const [leaveGameModal, setLeaveGameModal] = useState(false);
            const [mulliganSummaryModal, setMulliganSummaryModal] = useState(false);
            const [gameResult, setGameResult] = useState({ winner: '', confirmed: false });

            const playerLowerBattlefieldRef = useRef(null);
            const playerUpperBattlefieldRef = useRef(null);
            const initializingRef = useRef(null);
            const hasInitializedRef = useRef(false);

            const user = window.currentUser;
            const db = window.db;

            // Sync Room
            useEffect(() => {
                const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                const unsubscribe = window.onSnapshot(roomRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        setRoomState(data);
                        setLoading(false);
                        
                        // Game Result Modal
                        if (data.gameResult && !data.gameResult.confirmed && data.gameResult.submittedBy !== user.uid) {
                            setGameResult(data.gameResult); setLeaveGameModal(true);
                        }
                        
                        // Mulligan Summary Modal trigger
                        if (data.showMulliganSummary && !data.mulliganSummaryConfirmed?.[user.uid]) {
                            setMulliganSummaryModal(true);
                        }
                    } else { onLeave(); }
                });
                return () => unsubscribe();
            }, [roomId]);

            // Host Init (Starting Player & Phase)
            useEffect(() => {
                if (!loading && roomState && roomState.host === user.uid && roomState.players.length === 2) {
                    const updates = {};
                    if (!roomState.startingPlayer) {
                        const starter = Math.random() < 0.5 ? roomState.players[0] : roomState.players[1];
                        updates.startingPlayer = starter;
                        updates.currentTurn = starter; 
                    }
                    if (!roomState.phase) {
                        updates.phase = 'mulligan';
                    }
                    if (Object.keys(updates).length > 0) {
                         window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), updates);
                    }
                }
            }, [roomState, loading, user.uid, roomId]);

            // Player Init
            useEffect(() => {
                if (loading || !roomState) return;
                const myId = user.uid;
                if (roomState.gameState && roomState.gameState[myId]) { hasInitializedRef.current = true; return; }
                if (initializingRef.current || hasInitializedRef.current) return;
                initializingRef.current = true;
                
                const initLibrary = deck.cards.map(c => ({ ...c, instanceId: generateId(), isTapped: false, counters: [] }));
                for (let i = initLibrary.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [initLibrary[i], initLibrary[j]] = [initLibrary[j], initLibrary[i]]; }
                const startingHand = initLibrary.splice(0, 7);
                const commander = deck.commander ? [{ ...deck.commander, instanceId: generateId(), isTapped: false, counters: [] }] : [];

                const myState = {
                    library: initLibrary,
                    hand: startingHand,
                    battlefieldUpper: [],
                    battlefieldLower: [],
                    graveyard: [],
                    exile: [],
                    commandZone: commander,
                    life: 40,
                    commanderDamage: 0,
                    cmdTax: 0
                };

                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), {
                    [`gameState.${myId}`]: myState,
                    [`mulliganSummaryConfirmed.${myId}`]: false,
                }).then(() => {
                    hasInitializedRef.current = true;
                    initializingRef.current = false;
                });

            }, [roomState, loading, user.uid, roomId, deck]);

            const myState = roomState?.gameState?.[user.uid];
            const opponentId = roomState?.players?.find(id => id !== user.uid);
            const opponentState = roomState?.gameState?.[opponentId];
            const opponentName = roomState?.playerNames?.[opponentId] || 'Opponent';
            const startingPlayerId = roomState?.startingPlayer;
            const phase = roomState?.phase;
            const currentTurnId = roomState?.currentTurn;
            const isMyTurn = currentTurnId === user.uid;
            
            const showMulligan = phase === 'mulligan' && myState?.hand.length > 0;

            if (loading || !myState) return <div className="h-full flex flex-col items-center justify-center text-yellow-400"><div className="loader mb-4"></div><p>Syncing...</p></div>;

            const updateMyState = (updates) => {
                const updatePayload = {};
                Object.keys(updates).forEach(key => {
                    updatePayload[`gameState.${user.uid}.${key}`] = updates[key];
                });
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), updatePayload);
            };

            const drawCard = () => { 
                if (myState.library.length === 0) return; 
                
                // FEHLERBEHEBUNG: Der Block zur sofortigen Phasen-Umschaltung im Mulligan wurde entfernt.
                
                const newLib = [...myState.library]; 
                const card = newLib.shift(); 
                updateMyState({ library: newLib, hand: [...myState.hand, { ...card, instanceId: generateId() }] }); 
            };

            const shuffleLibrary = () => {
                const newLib = [...myState.library];
                for (let i = newLib.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newLib[i], newLib[j]] = [newLib[j], newLib[i]];
                }
                updateMyState({ library: newLib });
            };

            const playCard = (card, fromZone, toBattlefield, position = { x: 50, y: 50 }) => {
                const updates = {};
                const targetBattlefield = toBattlefield === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                const newCard = { ...card, isTapped: false, x: position.x, y: position.y, counters: [] };

                updates[targetBattlefield] = [...(myState[targetBattlefield] || []), newCard];

                if (fromZone === 'hand') updates.hand = myState.hand.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'command') {
                    updates.commandZone = myState.commandZone.filter(c => c.instanceId !== card.instanceId);
                    updates.cmdTax = (myState.cmdTax || 0) + 2;
                }
                else if (fromZone === 'graveyard') updates.graveyard = myState.graveyard.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'exile') updates.exile = myState.exile.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'library_top' || fromZone === 'library') updates.library = myState.library.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'battlefieldUpper') updates.battlefieldUpper = (myState.battlefieldUpper || []).filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'battlefieldLower') updates.battlefieldLower = (myState.battlefieldLower || []).filter(c => c.instanceId !== card.instanceId);

                updateMyState(updates);
            };

            const moveCardToZone = (card, toZone) => {
                const filter = c => c.instanceId !== card.instanceId;
                const updates = {};

                // Determine original zone and remove card
                if (myState.hand.some(filter)) updates.hand = myState.hand.filter(filter);
                else if (myState.battlefieldUpper.some(filter)) updates.battlefieldUpper = myState.battlefieldUpper.filter(filter);
                else if (myState.battlefieldLower.some(filter)) updates.battlefieldLower = myState.battlefieldLower.filter(filter);
                else if (myState.graveyard.some(filter)) updates.graveyard = myState.graveyard.filter(filter);
                else if (myState.exile.some(filter)) updates.exile = myState.exile.filter(filter);
                else if (myState.commandZone.some(filter)) updates.commandZone = myState.commandZone.filter(filter);
                else if (myState.library.some(filter)) updates.library = myState.library.filter(filter);

                // Add card to new zone
                const cardWithTaps = { ...card, isTapped: false, x: undefined, y: undefined, counters: card.counters || [] };

                if (toZone === 'hand') updates.hand = [...updates.hand, cardWithTaps];
                else if (toZone === 'graveyard') updates.graveyard = [...updates.graveyard, cardWithTaps];
                else if (toZone === 'exile') updates.exile = [...updates.exile, cardWithTaps];
                else if (toZone === 'command') updates.commandZone = [...updates.commandZone, cardWithTaps];
                else if (toZone === 'library_top') updates.library = [cardWithTaps, ...updates.library];
                else if (toZone === 'library_bottom') updates.library = [...updates.library, cardWithTaps];
                else if (toZone === 'library') {
                    // Default to bottom for shuffling later, or draw if it's during mulligan/game start
                    updates.library = [...updates.library, cardWithTaps];
                }
                
                updateMyState(updates);
            };

            const toggleTap = (instanceId, battlefieldZone) => {
                const zoneKey = battlefieldZone === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                const currentCards = myState[zoneKey] || [];
                const updatedCards = currentCards.map(c => 
                    c.instanceId !== instanceId ? c : { ...c, isTapped: !c.isTapped }
                );
                updateMyState({ [zoneKey]: updatedCards });
            };

            const createToken = (tokenData) => {
                 const newToken = { 
                    instanceId: generateId(), 
                    name: tokenData.name,
                    type: tokenData.type,
                    image_url: tokenData.image,
                    isTapped: false,
                    counters: [],
                    x: 100, // default position
                    y: 100
                };
                updateMyState({ battlefieldLower: [...(myState.battlefieldLower || []), newToken] });
                setTokenSelectorModalOpen(false);
            };

            const handleCustomTokenCreate = () => {
                const { name, power, toughness, colors, imageUrl } = customTokenData;
                let finalImage = imageUrl;

                if (!imageUrl) {
                    const selectedColors = COLOR_DATA.filter(c => colors[c.id]);
                    const bgColor = selectedColors.length > 0 ? selectedColors[0].hex : '#4B5563'; // Default to a grey
                    const textColor = selectedColors.length > 0 && selectedColors[0].text === 'text-yellow-900' ? '#1F2937' : '#FFFFFF';
                    const bgColorHex = bgColor.substring(1);
                    const textColorHex = textColor.substring(1);
                    
                    const stats = power && toughness ? `${power}/${toughness}` : '';
                    const displayName = name || 'Token';
                    const text = `${displayName}\n${stats}`;
                    
                    // Using placehold.co for dynamic image generation
                    finalImage = `https://placehold.co/400x560/${bgColorHex}/${textColorHex}.png?text=${encodeURIComponent(text)}`;
                }

                createToken({ 
                    name: name || 'Token', 
                    type: 'Token', 
                    image: finalImage 
                });

                // Reset form
                setCustomTokenData({ name: '', power: '1', toughness: '1', colors: { W:false, U:false, B:false, R:false, G:false }, imageUrl: '' });
            };

            const updateCardCounters = (card, counterType, battlefieldZone) => {
                const zoneKey = battlefieldZone === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                const currentCards = myState[zoneKey] || [];
                const updatedCards = currentCards.map(c => c.instanceId !== card.instanceId ? c : { ...c, counters: [...(c.counters || []), counterType] });
                updateMyState({ [zoneKey]: updatedCards });
            };

            const removeCounter = (card, index, battlefieldZone) => {
                const zoneKey = battlefieldZone === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                const currentCards = myState[zoneKey] || [];
                const updatedCards = currentCards.map(c => {
                    if (c.instanceId !== card.instanceId) return c;
                    const newCounters = [...(c.counters || [])];
                    newCounters.splice(index, 1);
                    return { ...c, counters: newCounters };
                });
                updateMyState({ [zoneKey]: updatedCards });
            };

            const passTurn = () => {
                if (currentTurnId === user.uid) {
                    const nextPlayerId = roomState.players.find(id => id !== user.uid);
                    // Untap all permanent on the battlefield for the current player before passing the turn
                    const untappedLower = (myState.battlefieldLower || []).map(c => ({ ...c, isTapped: false }));
                    const untappedUpper = (myState.battlefieldUpper || []).map(c => ({ ...c, isTapped: false }));
                    const untappedCmd = (myState.commandZone || []).map(c => ({ ...c, isTapped: false }));

                    window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), {
                        currentTurn: nextPlayerId,
                        [`gameState.${user.uid}.battlefieldLower`]: untappedLower,
                        [`gameState.${user.uid}.battlefieldUpper`]: untappedUpper,
                        [`gameState.${user.uid}.commandZone`]: untappedCmd,
                    });
                }
            };
            
            const submitGameResult = (winnerId) => {
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), {
                    gameResult: {
                        winner: winnerId,
                        submittedBy: user.uid,
                        confirmed: false,
                        submittedAt: Date.now()
                    },
                    // Also clear mulligan flags to prepare for a new game if desired
                    showMulliganSummary: false,
                    mulliganSummaryConfirmed: {}
                });
                setLeaveGameModal(false); 
            };
            
            const confirmGameResult = () => {
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), {
                    'gameResult.confirmed': true,
                }).then(() => {
                    setLeaveGameModal(false);
                    setGameResult({ winner: '', confirmed: true });
                });
            };
            
            const disputeGameResult = () => {
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), {
                    gameResult: null,
                });
                setLeaveGameModal(false);
                setGameResult({ winner: '', confirmed: false });
            };
            
            const confirmMulliganSummary = () => {
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), {
                    [`mulliganSummaryConfirmed.${user.uid}`]: true
                });
                setMulliganSummaryModal(false);
            };

            const handleDragStart = (e, card, fromZone) => {
                setDraggedCard({ card, fromZone, initialX: e.clientX, initialY: e.clientY });
                e.dataTransfer.setDragImage(new Image(), 0, 0); // Hide default drag image
            };

            const handleDropOnBattlefield = (e, targetBattlefield) => {
                e.preventDefault();
                if (!draggedCard) return;

                const targetRef = targetBattlefield === 'upper' ? playerUpperBattlefieldRef : playerLowerBattlefieldRef;
                const rect = targetRef.current.getBoundingClientRect();
                
                // Calculate position relative to the battlefield zone (not the whole screen)
                let x = e.clientX - rect.left - 45; // 45 = half card width (90px)
                let y = e.clientY - rect.top - 60; // 60 = half card height (120px)

                // Clamp position within the bounds
                x = Math.max(0, Math.min(rect.width - 90, x));
                y = Math.max(0, Math.min(rect.height - 120, y));

                const movedCard = { ...draggedCard.card, x, y, isTapped: false, counters: draggedCard.card.counters || [] };
                
                // Check if card is moving between battlefield zones
                if (draggedCard.fromZone.startsWith('battlefield')) {
                    const updates = {};
                    const otherZoneKey = targetBattlefield === 'upper' ? 'battlefieldLower' : 'battlefieldUpper';
                    const targetZoneKey = targetBattlefield === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';

                    if (draggedCard.fromZone === targetZoneKey) {
                        // Moving within the same zone (just reposition)
                        updates[targetZoneKey] = (myState[targetZoneKey] || []).map(c => 
                            c.instanceId === movedCard.instanceId ? movedCard : c
                        );
                    } else if (draggedCard.fromZone === otherZoneKey) {
                        // Moving from opponent's battlefield to mine (this should not happen in a strict two-player view, but for completeness)
                        // In this setup, only my cards are draggable, so this case is for moving between my upper and lower zones.
                        updates[otherZoneKey] = (myState[otherZoneKey] || []).filter(c => c.instanceId !== movedCard.instanceId);
                        updates[targetZoneKey] = [...(myState[targetZoneKey] || []), movedCard];
                    } else {
                         // Repositioning a card from other zones (like hand/graveyard) which is handled by playCard/moveCardToZone
                    }

                    if (Object.keys(updates).length > 0) {
                        updateMyState(updates);
                    }
                } else {
                    // Playing a card from hand/command/etc.
                    playCard(draggedCard.card, draggedCard.fromZone, targetBattlefield, { x, y });
                }

                setDraggedCard(null);
            };

            const handleDragEnd = (e) => {
                if (!draggedCard) return;

                const cardWidth = 90;
                const cardHeight = 120;
                const dragX = e.clientX;
                const dragY = e.clientY;

                // 1. Check drop on Battlefield (handles x, y positioning and zone change)
                const lowerRect = playerLowerBattlefieldRef.current.getBoundingClientRect();
                const upperRect = playerUpperBattlefieldRef.current.getBoundingClientRect();

                if (dragX >= lowerRect.left && dragX <= lowerRect.right && dragY >= lowerRect.top && dragY <= lowerRect.bottom) {
                    handleDropOnBattlefield(e, 'lower');
                    setDraggedCard(null);
                    return;
                }
                if (dragX >= upperRect.left && dragX <= upperRect.right && dragY >= upperRect.top && dragY <= upperRect.bottom) {
                    handleDropOnBattlefield(e, 'upper');
                    setDraggedCard(null);
                    return;
                }

                // 2. Reposition within the same battlefield if released outside but was from battlefield
                if (draggedCard.fromZone.startsWith('battlefield')) {
                    const targetBattlefield = draggedCard.fromZone === 'battlefieldUpper' ? 'upper' : 'lower';
                    const rect = targetBattlefield === 'upper' ? upperRect : lowerRect;

                    let x = dragX - rect.left - (cardWidth / 2);
                    let y = dragY - rect.top - (cardHeight / 2);

                    x = Math.max(0, Math.min(rect.width - cardWidth, x));
                    y = Math.max(0, Math.min(rect.height - cardHeight, y));

                    const movedCard = { ...draggedCard.card, x, y };

                    const zoneKey = draggedCard.fromZone;
                    const updatedCards = (myState[zoneKey] || []).map(c => 
                        c.instanceId === movedCard.instanceId ? movedCard : c
                    );
                    updateMyState({ [zoneKey]: updatedCards });
                }
                
                setDraggedCard(null);
            };


            const handleDropOnZone = (e, zone) => {
                e.preventDefault();
                if (!draggedCard) return;
                const target = zone === 'library' ? 'library_top' : zone;

                // Check if card is moving to itself
                if (draggedCard.fromZone === target || (draggedCard.fromZone === 'library_top' && target === 'library')) {
                    setDraggedCard(null);
                    return;
                }

                moveCardToZone(draggedCard.card, target);
                setDraggedCard(null);
            };

            const openCardContextMenu = (e, card, zone) => {
                e.preventDefault();
                e.stopPropagation();
                
                const battlefieldZone = zone === 'battlefieldUpper' ? 'upper' : 'lower';

                let options = [
                    { header: 'Card Actions' },
                    { label: card.isTapped ? 'Untap' : 'Tap', action: () => toggleTap(card.instanceId, battlefieldZone) },
                    { label: 'To Hand', action: () => moveCardToZone(card, 'hand') },
                    { label: 'To Graveyard', action: () => moveCardToZone(card, 'graveyard') },
                    { label: 'To Exile', action: () => moveCardToZone(card, 'exile') },
                    { label: 'To Command Zone', action: () => moveCardToZone(card, 'command') },
                    { divider: true },
                    { header: 'Counters' }
                ];
                
                // Add counter options
                COUNTER_TYPES.forEach(ct => {
                    options.push({ 
                        label: `Add ${ct.label}`, 
                        action: () => updateCardCounters(card, ct, battlefieldZone), 
                        rightIcon: '+'
                    });
                });

                // Add remove counter options
                if (card.counters && card.counters.length > 0) {
                    options.push({ divider: true });
                    options.push({ header: 'Remove Counter' });
                    card.counters.forEach((c, index) => {
                        options.push({
                            label: `Remove ${c.label}`,
                            action: () => removeCounter(card, index, battlefieldZone),
                            rightIcon: '-'
                        });
                    });
                }
                
                options.push({ divider: true });
                options.push({ label: 'To Bottom of Library', action: () => moveCardToZone(card, 'library_bottom') });
                options.push({ label: 'To Top of Library', action: () => moveCardToZone(card, 'library_top') });


                setCardContextMenu({ x: e.clientX, y: e.clientY, options });
            };

            const mulliganHand = () => {
                const numCards = myState.hand.length;
                if (numCards <= 0) return;

                // Move current hand to library
                const cardsToShuffle = myState.hand.map(c => ({...c, isTapped: false, x: undefined, y: undefined}));
                const newLibrary = [...myState.library, ...cardsToShuffle];
                
                // Shuffle new library
                for (let i = newLibrary.length - 1; i > 0; i--) { 
                    const j = Math.floor(Math.random() * (i + 1)); 
                    [newLibrary[i], newLibrary[j]] = [newLibrary[j], newLibrary[i]]; 
                }

                // Draw new hand (N-1)
                const newHandSize = Math.max(0, numCards - 1);
                const newHand = newLibrary.splice(0, newHandSize);
                
                updateMyState({ 
                    hand: newHand, 
                    library: newLibrary,
                    // If the starting hand size was 7, this is the first mulligan, so keep the flag false.
                    // Otherwise, set to true to disable further mulligans below 6 cards (optional)
                    // The standard EDH rule is N-1 for first, then scry 1 for second. This simple logic just does N-1.
                });

                // Note: The UI "Keep Hand" button now needs to handle the phase switch to 'game'
            };
            
            const keepHandAndStartGame = () => {
                 // 1. Mark my mulligan as confirmed
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), {
                    [`mulliganSummaryConfirmed.${user.uid}`]: true
                });
                
                // 2. Scry 1 if hand size is < 7 (simple rule, may need refinement)
                // For simplicity, we just mark confirmed. The Scry logic can be implemented separately if needed.
                
                // 3. Check if all players are confirmed. If so, switch phase to 'game' and show summary.
                // The main listener (useEffect at the top) handles the phase switch when all players confirm.
            };

            // Calculate space for battlefields
            const handHeight = myHandMinimized ? 0 : 180;
            const battlefieldHeight = `calc(100vh - 80px - ${handHeight}px - 200px)`; 
            
            // Render everything
            return (
                <div className="h-full w-full flex flex-col">
                    <Header user={user} selectedDeck={deck} />

                    {/* Main Game Area */}
                    <div className="flex-grow relative overflow-hidden" onDragOver={e => e.preventDefault()} onDragEnd={handleDragEnd} onDrop={handleDragEnd}>
                        
                        {/* --- OPPONENT ZONE --- */}
                        <div ref={playerUpperBattlefieldRef} className="absolute top-0 left-0 right-0 h-[200px] bg-gray-900/50 border-b border-gray-700 p-2 overflow-hidden" onDrop={(e) => handleDropOnBattlefield(e, 'upper')} onDragOver={e => e.preventDefault()}>
                            <div className="absolute inset-0 z-0 opacity-10 bg-[url('https://upload.wikimedia.org/wikipedia/commons/e/ec/Commander_symbol.svg')] bg-center bg-no-repeat bg-contain"></div>
                            <h3 className="text-gray-500 font-bold text-sm">Opponent Battlefield</h3>
                            <div className="relative w-full h-full">
                                {(opponentState?.battlefieldUpper || []).map(card => (<div key={card.instanceId} className="absolute" style={{ left: card.x, top: card.y }}><CardImage src={card.image_url} counters={card.counters} className={`w-[60px] h-[80px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`} /></div>))}
                                {(opponentState?.battlefieldLower || []).map(card => (<div key={card.instanceId} className="absolute" style={{ left: card.x, top: card.y }}><CardImage src={card.image_url} counters={card.counters} className={`w-[60px] h-[80px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`} /></div>))}
                            </div>
                        </div>

                        {/* --- MIDDLE BATTLEFIELD --- */}
                        <div ref={playerLowerBattlefieldRef} className="absolute left-0 right-0 p-2 bg-gray-900/80 border-t border-gray-700" style={{ top: '200px', height: battlefieldHeight }} onDrop={(e) => handleDropOnBattlefield(e, 'lower')} onDragOver={e => e.preventDefault()}>
                             <div className="absolute inset-0 z-0 opacity-10 bg-[url('https://upload.wikimedia.org/wikipedia/commons/e/ec/Commander_symbol.svg')] bg-center bg-no-repeat bg-contain"></div>
                            <h3 className="text-yellow-400 font-bold text-sm">Your Battlefield</h3>
                            <div className="relative w-full h-full">
                                {/* Dropped Cards */}
                                {(myState.battlefieldUpper || []).map(card => (<div key={card.instanceId} className="absolute cursor-pointer" style={{ left: card.x, top: card.y }} draggable onDragStart={(e) => handleDragStart(e, card, 'battlefieldUpper')} onContextMenu={(e) => openCardContextMenu(e, card, 'battlefieldUpper')}><CardImage src={card.image_url} counters={card.counters} className={`w-[90px] h-[120px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`} onClick={() => toggleTap(card.instanceId, 'upper')} onMouseEnter={() => setHoveredCard(card.image_url)} onMouseLeave={() => setHoveredCard(null)} /></div>))}
                                {(myState.battlefieldLower || []).map(card => (<div key={card.instanceId} className="absolute cursor-pointer" style={{ left: card.x, top: card.y }} draggable onDragStart={(e) => handleDragStart(e, card, 'battlefieldLower')} onContextMenu={(e) => openCardContextMenu(e, card, 'battlefieldLower')}><CardImage src={card.image_url} counters={card.counters} className={`w-[90px] h-[120px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`} onClick={() => toggleTap(card.instanceId, 'lower')} onMouseEnter={() => setHoveredCard(card.image_url)} onMouseLeave={() => setHoveredCard(null)} /></div>))}
                            </div>
                        </div>

                        {/* --- PLAYER UI --- */}
                        <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 z-50 flex flex-col items-center">
                            {isMyTurn && phase === 'game' && (
                                <button onClick={passTurn} className="mb-2 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-2 px-6 rounded-full shadow-lg border-2 border-yellow-400 animate-bounce">
                                    Pass Turn
                                </button>
                            )}
                            {myHandMinimized ? (
                                <button onClick={() => setMyHandMinimized(false)} className="bg-blue-900/90 backdrop-blur-sm px-4 py-1 rounded-t-lg border border-blue-500/50 text-blue-400 font-bold text-xs shadow-lg hover:bg-blue-800 transition-colors">Maximize Hand</button>
                            ) : (
                                <div className="bg-blue-900/90 backdrop-blur-sm px-4 py-2 rounded-t-lg border-t border-x border-blue-500/50 shadow-2xl transition-all duration-300">
                                    <h3 className="text-blue-300 text-sm font-bold mb-2 flex justify-between items-center">
                                        Your Hand ({myState.hand.length})
                                        <button onClick={() => setMyHandMinimized(true)} className="text-blue-400 hover:text-white">
                                             <i data-lucide="minimize-2" className="w-4 h-4"></i>
                                        </button>
                                    </h3>
                                    <div className="flex space-x-2 overflow-x-auto pb-2 scrollbar-hide" style={{ width: 'min(90vw, 900px)' }}>
                                        {myState.hand.map((card, index) => (
                                            <div key={card.instanceId} className={`flex-shrink-0 cursor-grab ${draggedCard?.card?.instanceId === card.instanceId ? 'opacity-30' : ''}`} draggable onDragStart={(e) => handleDragStart(e, card, 'hand')} onContextMenu={(e) => openCardContextMenu(e, card, 'hand')}>
                                                <CardImage 
                                                    src={card.image_url} 
                                                    className="w-[90px] h-[120px] card-shadow" 
                                                    onMouseEnter={() => setHoveredCard(card.image_url)} 
                                                    onMouseLeave={() => setHoveredCard(null)} 
                                                />
                                            </div>
                                        ))}
                                    </div>
                                    {showMulligan && (
                                        <div className="flex justify-center gap-4 mt-2 pt-2 border-t border-blue-800">
                                            <button onClick={mulliganHand} className="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                                                Mulligan (Draw {Math.max(0, myState.hand.length - 1)})
                                            </button>
                                            <button onClick={keepHandAndStartGame} className="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                                                Keep Hand
                                            </button>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                        
                        {/* --- PLAYER INFO AND UTILITIES (Left) --- */}
                        <div className="absolute bottom-4 left-2 z-40 w-56 flex flex-col gap-2 pointer-events-none">
                            <div className={`pointer-events-auto bg-green-900/80 backdrop-blur-sm p-4 rounded-lg border flex-shrink-0 shadow-lg transition-all duration-500 ${currentTurnId === user.uid ? 'active-turn border-green-500' : 'border-green-500/50'}`}>
                                <div className="flex justify-between items-center mb-2">
                                    <h4 className="text-green-400 text-sm font-bold flex items-center gap-2">
                                         You {currentTurnId === user.uid && <span className="bg-green-600 text-white text-[10px] px-2 py-0.5 rounded-full animate-pulse">TURN</span>}
                                    </h4>
                                    {startingPlayerId === user.uid && <Coin />}
                                </div>
                                <div className="text-white text-sm space-y-1">
                                    <div className="flex items-center justify-between">
                                        <span>Life:</span>
                                        <span className="text-green-400 font-bold text-lg">{myState.life}</span>
                                    </div>
                                    <div className="flex gap-1">
                                        <button onClick={() => updateMyState({ life: myState.life + 1 })} className="flex-1 bg-green-600 px-2 py-1 rounded text-xs hover:bg-green-500">+</button>
                                        <button onClick={() => updateMyState({ life: myState.life - 1 })} className="flex-1 bg-red-600 px-2 py-1 rounded text-xs hover:bg-red-500">-</button>
                                    </div>
                                    <div className="flex items-center justify-between mt-2">
                                        <span>Cmd Dmg:</span>
                                        <span className="text-red-400 font-bold">{myState.commanderDamage || 0}</span>
                                    </div>
                                    <div className="flex gap-1">
                                        <button onClick={() => { 
                                            const currentCmdDmg = myState.commanderDamage || 0; 
                                            updateMyState({ commanderDamage: currentCmdDmg + 1, life: myState.life - 1 }); 
                                        }} className="flex-1 bg-red-600 px-2 py-1 rounded text-xs hover:bg-red-500">+</button>
                                        <button onClick={() => { 
                                            const currentCmdDmg = myState.commanderDamage || 0; 
                                            if (currentCmdDmg > 0) updateMyState({ commanderDamage: currentCmdDmg - 1, life: myState.life + 1 }); 
                                        }} className="flex-1 bg-green-600 px-2 py-1 rounded text-xs hover:bg-green-500" disabled={!(myState.commanderDamage > 0)}>-</button>
                                    </div>
                                </div>
                            </div>

                            <div className="pointer-events-auto bg-blue-900/80 backdrop-blur-sm p-3 rounded-lg border border-blue-500/50 shadow-lg">
                                <h4 className="text-blue-400 text-sm font-bold mb-2 flex-shrink-0">Utilities</h4>
                                <div className="flex flex-wrap gap-2 text-xs">
                                    <button onClick={() => setTokenSelectorModalOpen(true)} className="bg-purple-600 hover:bg-purple-500 text-white py-1 px-2 rounded font-bold">Token</button>
                                    <button onClick={() => setViewingZone('graveyard')} className="bg-gray-600 hover:bg-gray-500 text-white py-1 px-2 rounded font-bold">GY ({myState.graveyard.length})</button>
                                    <button onClick={() => setViewingZone('exile')} className="bg-gray-600 hover:bg-gray-500 text-white py-1 px-2 rounded font-bold">Exile ({myState.exile.length})</button>
                                </div>
                            </div>
                        </div>


                        {/* --- OPPONENT INFO AND COMMAND ZONE (Right-Top) --- */}
                        <div className="absolute top-4 left-2 z-40 w-56 flex flex-col gap-2 pointer-events-none">
                            <div className={`pointer-events-auto bg-red-900/80 backdrop-blur-sm p-4 rounded-lg border flex-shrink-0 shadow-lg transition-all duration-500 ${currentTurnId === opponentId ? 'active-turn-opp border-red-500' : 'border-red-500/50'}`}>
                                <div className="flex justify-between items-center mb-2">
                                    <h4 className="text-red-400 text-sm font-bold flex items-center gap-2">
                                        {opponentName} {currentTurnId === opponentId && <span className="bg-red-600 text-white text-[10px] px-2 py-0.5 rounded-full animate-pulse">TURN</span>}
                                    </h4>
                                    {startingPlayerId === opponentId && <Coin />}
                                </div>
                                <div className="text-white text-sm space-y-1">
                                    <div>Life: <span className="text-green-400 font-bold text-lg">{opponentState.life}</span></div>
                                    <div>Cmd Dmg: <span className="text-red-400 font-bold">{opponentState.commanderDamage || 0}</span></div>
                                </div>
                            </div>

                            {opponentState?.commandZone?.length > 0 && (
                                <div className="pointer-events-auto bg-red-900/80 backdrop-blur-sm p-3 rounded-lg border border-red-500/50 overflow-hidden flex flex-col shadow-lg">
                                    <h4 className="text-red-400 text-sm font-bold mb-2 flex-shrink-0">Command Zone</h4>
                                    <div className="flex flex-wrap gap-2 content-start">
                                        {opponentState.commandZone.map(card => (
                                            <div key={card.instanceId} className="relative">
                                                <CardImage src={card.image_url} className={`w-[40px] h-[55px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`} />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* --- PLAYER COMMAND ZONE & LIBRARY (Right-Bottom) --- */}
                        <div className="absolute bottom-4 right-2 z-40 w-56 flex flex-col gap-2 pointer-events-none">
                             {myState.commandZone?.length > 0 && (
                                <div className="pointer-events-auto bg-blue-900/80 backdrop-blur-sm p-3 rounded-lg border border-blue-500/50 overflow-hidden flex flex-col shadow-lg">
                                    <h4 className="text-blue-400 text-sm font-bold mb-2 flex-shrink-0">Command Zone (Tax: +{myState.cmdTax || 0})</h4>
                                    <div className="flex flex-wrap gap-2 content-start">
                                        {myState.commandZone.map(card => (
                                            <div key={card.instanceId} className="relative cursor-pointer" draggable onDragStart={(e) => handleDragStart(e, card, 'command')} onContextMenu={(e) => openCardContextMenu(e, card, 'command')}>
                                                <CardImage 
                                                    src={card.image_url} 
                                                    className={`w-[40px] h-[55px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`} 
                                                    onClick={() => moveCardToZone(card, 'hand')} // Default action
                                                    onMouseEnter={() => setHoveredCard(card.image_url)} 
                                                    onMouseLeave={() => setHoveredCard(null)} 
                                                />
                                                <span className="absolute -top-1 -right-1 bg-yellow-600 text-black text-[8px] font-bold px-1 rounded-full shadow-md border border-black/20 z-10">{myState.cmdTax || 0}</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <div className="pointer-events-auto bg-gray-900/80 backdrop-blur-sm p-3 rounded-lg border border-gray-700 shadow-lg flex justify-between items-center">
                                <h4 className="text-gray-400 text-sm font-bold flex items-center gap-2">
                                    Library ({myState.library.length})
                                </h4>
                                <button onClick={(e) => setLibraryMenu({ x: e.clientX, y: e.clientY })} className="bg-gray-700 hover:bg-gray-600 text-white p-1 rounded-full text-xs">
                                     <i data-lucide="menu" className="w-4 h-4"></i>
                                </button>
                            </div>

                            <div className="pointer-events-auto bg-yellow-900/80 backdrop-blur-sm p-3 rounded-lg border border-yellow-500/50 shadow-lg flex justify-between items-center">
                                <h4 className="text-yellow-400 text-sm font-bold flex items-center gap-2">
                                    <i data-lucide="trophy" className="w-4 h-4"></i> Game Result
                                </h4>
                                <button onClick={() => setLeaveGameModal(true)} className="bg-yellow-600 hover:bg-yellow-500 text-white py-1 px-2 rounded text-xs font-bold">End Game</button>
                            </div>
                        </div>

                    </div>

                    {/* Modals and Context Menus */}
                    {viewingZone && (
                        <Modal isOpen={!!viewingZone} onClose={() => setViewingZone(null)} title={viewingZone.charAt(0).toUpperCase() + viewingZone.slice(1)}>
                            <div className="grid grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-4 max-h-[70vh] overflow-y-auto p-2">
                                {(myState[viewingZone] || []).map(card => (
                                    <div key={card.instanceId} className="relative cursor-pointer" draggable onDragStart={(e) => handleDragStart(e, card, viewingZone)} onContextMenu={(e) => openCardContextMenu(e, card, viewingZone)}>
                                        <CardImage 
                                            src={card.image_url} 
                                            className="w-full aspect-[5/7] rounded-xl shadow-lg" 
                                            onMouseEnter={() => setHoveredCard(card.image_url)} 
                                            onMouseLeave={() => setHoveredCard(null)} 
                                            onClick={() => moveCardToZone(card, 'hand')}
                                        />
                                    </div>
                                ))}
                                {myState[viewingZone]?.length === 0 && <p className="text-gray-500 col-span-full">This zone is empty.</p>}
                            </div>
                        </Modal>
                    )}

                    {tokenSelectorModalOpen && (
                        <Modal isOpen={true} onClose={() => setTokenSelectorModalOpen(false)} title="Create Token">
                            <div className="flex border-b border-gray-700 mb-4">
                                <button onClick={() => setTokenTab('common')} className={`px-4 py-2 font-bold ${tokenTab === 'common' ? 'text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400 hover:text-white'}`}>Common Tokens</button>
                                <button onClick={() => setTokenTab('custom')} className={`px-4 py-2 font-bold ${tokenTab === 'custom' ? 'text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400 hover:text-white'}`}>Custom Token/Image</button>
                            </div>

                            {tokenTab === 'common' ? (
                                <div className="grid grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-4 max-h-[60vh] overflow-y-auto">
                                    {COMMON_TOKENS.map(token => (
                                        <div key={token.name} onClick={() => createToken(token)} className="cursor-pointer hover:bg-gray-700/50 p-2 rounded-lg transition-colors flex flex-col items-center">
                                            <img src={token.image} className="w-full rounded mb-2 object-cover aspect-[5/7]" />
                                            <span className="text-xs font-bold text-center">{token.name}</span>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Name / Type</label>
                                        <input type="text" value={customTokenData.name} onChange={e => setCustomTokenData({...customTokenData, name: e.target.value})} className="w-full bg-gray-700 border border-gray-600 rounded p-2 text-white" placeholder="e.g. Elf Warrior" />
                                    </div>
                                    <div className="flex gap-4">
                                        <div className="flex-1">
                                            <label className="block text-sm text-gray-400 mb-1">Power</label>
                                            <input type="text" value={customTokenData.power} onChange={e => setCustomTokenData({...customTokenData, power: e.target.value})} className="w-full bg-gray-700 border border-gray-600 rounded p-2 text-white text-center" />
                                        </div>
                                        <div className="flex-1">
                                            <label className="block text-sm text-gray-400 mb-1">Toughness</label>
                                            <input type="text" value={customTokenData.toughness} onChange={e => setCustomTokenData({...customTokenData, toughness: e.target.value})} className="w-full bg-gray-700 border border-gray-600 rounded p-2 text-white text-center" />
                                        </div>
                                    </div>
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-2">Colors (Background)</label>
                                        <div className="flex justify-center gap-3">
                                            {COLOR_DATA.map(c => (
                                                <button key={c.id} onClick={() => setCustomTokenData({ ...customTokenData, colors: { ...customTokenData.colors, [c.id]: !customTokenData.colors[c.id] }})} className={`w-10 h-10 rounded-full border-2 ${customTokenData.colors[c.id] ? `border-white shadow-xl` : 'border-gray-500 opacity-50 hover:opacity-100'}`} style={{ backgroundColor: c.hex }} title={c.label}>
                                                    <span className="sr-only">{c.label}</span>
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Image URL (Optional, overrides Power/Toughness/Colors)</label>
                                        <input type="url" value={customTokenData.imageUrl} onChange={e => setCustomTokenData({...customTokenData, imageUrl: e.target.value})} className="w-full bg-gray-700 border border-gray-600 rounded p-2 text-white" placeholder="e.g. https://scryfall.io/my-token.jpg" />
                                    </div>
                                    <button onClick={handleCustomTokenCreate} className="w-full bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-2 rounded mt-4">Create Custom Token</button>
                                </div>
                            )}
                        </Modal>
                    )}

                    {mulliganSummaryModal && (
                         <Modal isOpen={true} onClose={() => {}} title="Mulligan Confirmed">
                            <div className="space-y-4">
                                <p className="text-lg text-gray-300">Your opponent has confirmed their starting hand.</p>
                                <p className="text-yellow-400 font-bold">Confirm your hand to start the game.</p>
                                <div className="flex justify-center gap-4">
                                    <button onClick={confirmMulliganSummary} className="bg-green-600 hover:bg-green-500 px-6 py-2 rounded text-white font-bold">Start Game</button>
                                </div>
                            </div>
                        </Modal>
                    )}
                    
                    {leaveGameModal && (
                        <Modal isOpen={true} onClose={() => setLeaveGameModal(false)} title="Game Over">
                            <div className="space-y-4">
                                {gameResult.submittedBy === user.uid ? (
                                    <p className="text-lg text-gray-300">Waiting for your opponent to confirm the result. Winner: <span className="text-yellow-400 font-bold">{gameResult.winner === user.uid ? 'You' : opponentName}</span></p>
                                ) : (
                                    <p className="text-lg text-gray-300">Your opponent submitted the result. Winner: <span className="text-yellow-400 font-bold">{gameResult.winner === user.uid ? 'You' : opponentName}</span></p>
                                )}
                                
                                {gameResult.submittedBy !== user.uid && (
                                    <div className="flex justify-center gap-4">
                                        <button onClick={confirmGameResult} className="bg-green-600 hover:bg-green-500 px-6 py-2 rounded text-white font-bold">Confirm</button>
                                        <button onClick={disputeGameResult} className="bg-red-600 hover:bg-red-500 px-6 py-2 rounded text-white font-bold">Dispute</button>
                                    </div>
                                )}
                            </div>
                        </Modal>
                    )}
                    
                    {hoveredCard && <div className="fixed top-20 right-4 z-[100] pointer-events-none w-64 h-[350px] rounded-xl overflow-hidden shadow-2xl border-2 border-yellow-500 bg-black"><img src={hoveredCard} className="w-full h-full object-contain" /></div>}
                    
                    {libraryMenu && <ContextMenu x={libraryMenu.x} y={libraryMenu.y} onClose={() => setLibraryMenu(null)} options={[
                        { label: 'Draw Card', action: drawCard },
                        { label: 'Look at Top Card', action: () => { if(myState.library.length>0) setTopCardView(myState.library[0]); } },
                        { label: 'Shuffle Library', action: shuffleLibrary },
                        { label: 'View Entire Library', action: () => setViewingZone('library') }
                    ]} /> }
                    
                    {cardContextMenu && <ContextMenu x={cardContextMenu.x} y={cardContextMenu.y} onClose={() => setCardContextMenu(null)} options={cardContextMenu.options} />}
                    
                    {topCardView && <Modal isOpen={true} onClose={() => setTopCardView(null)} title="Top of Library">
                        <div className="flex flex-col items-center gap-4">
                            <img src={topCardView.image_url} className="w-48 rounded-xl shadow-lg" />
                            <div className="flex gap-4">
                                <button onClick={() => { setTopCardView(null); }} className="bg-blue-600 px-4 py-2 rounded text-white">Keep on Top</button>
                                <button onClick={() => { moveCardToZone(topCardView, 'library_bottom'); setTopCardView(null); }} className="bg-yellow-600 px-4 py-2 rounded text-white">Put on Bottom</button>
                                <button onClick={() => { playCard(topCardView, 'library_top', 'lower'); setTopCardView(null); }} className="bg-green-600 px-4 py-2 rounded text-white">Draw and Play</button>
                            </div>
                        </div>
                    </Modal>}

                </div>
            );
        };

        const RoomTimer = ({ emptyAt }) => {
            const [timeLeft, setTimeLeft] = useState(0);
            
            useEffect(() => {
                if (!emptyAt) return;

                const updateTimer = () => {
                    const remaining = Math.max(0, emptyAt - Date.now());
                    setTimeLeft(remaining);
                    if (remaining === 0) {
                        clearInterval(interval);
                    }
                };

                updateTimer();
                const interval = setInterval(updateTimer, 1000);
                return () => clearInterval(interval);
            }, [emptyAt]);

            if (!emptyAt) return null;

            const seconds = Math.floor(timeLeft / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            const isWarning = timeLeft < 60000;

            return <div className={`text-xs ${isWarning ? 'text-red-400 timer-warning' : 'text-gray-400'}`}> {minutes}:{remainingSeconds.toString().padStart(2, '0')}</div>;
        };

        const App = ({ user }) => {
            const [view, setView] = useState('lobby');
            const [selectedDeck, setSelectedDeck] = useState(null);
            const [decks, setDecks] = useState([]);
            const [rooms, setRooms] = useState([]);
            const [currentRoomId, setCurrentRoomId] = useState(null);

            // Load Decks
            useEffect(() => {
                const loadDecks = async () => {
                    const deckCollection = window.collection(window.db, 'decks');
                    const q = window.query(deckCollection, window.where('userId', '==', user.uid));
                    const snapshot = await window.getDocs(q);
                    const loadedDecks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setDecks(loadedDecks);
                    
                    // Auto-select first deck if none selected
                    if (!selectedDeck && loadedDecks.length > 0) {
                        setSelectedDeck(loadedDecks[0]);
                    }
                };
                loadDecks();
            }, [user]);

            // Live Room Updates
            useEffect(() => {
                if (view !== 'lobby') return;
                const publicRooms = window.getPublicRoomCollection();
                const q = window.query(publicRooms, window.where('active', '==', true)); 

                const unsubscribe = window.onSnapshot(q, (snapshot) => {
                    const loadedRooms = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                        .filter(room => room.players.length < 2 || room.players.includes(user.uid)) // Only show rooms that are not full, or the one the user is in.
                        .sort((a, b) => (a.emptyAt ? 1 : 0) - (b.emptyAt ? 1 : 0)); // Put closing rooms at the bottom

                    setRooms(loadedRooms);

                    // Check if the user is in a room that needs to transition to 'game'
                    const userRoom = loadedRooms.find(r => r.players.includes(user.uid));
                    if (userRoom && userRoom.phase === 'game') {
                        setCurrentRoomId(userRoom.id);
                        setView('game');
                    }
                    
                    // Check for rooms where the other player left
                    const myActiveRoom = loadedRooms.find(r => r.players.includes(user.uid) && r.players.length === 1 && !r.emptyAt);
                    if (myActiveRoom && myActiveRoom.host === user.uid) {
                         const emptyAt = Date.now() + ROOM_TIMEOUT_MS;
                         window.updateDoc(window.doc(window.getPublicRoomCollection(), myActiveRoom.id), {
                             emptyAt: emptyAt
                         });
                    }
                });

                return () => unsubscribe();
            }, [user.uid, view]);

            const createRoom = async () => {
                if (!selectedDeck) {
                    alert("Please select a deck first.");
                    return;
                }
                const newRoomRef = window.doc(window.getPublicRoomCollection());
                const newRoomId = newRoomRef.id;

                try {
                    await window.setDoc(newRoomRef, {
                        id: newRoomId,
                        host: user.uid,
                        hostName: user.displayName || user.email.split('@')[0],
                        players: [user.uid],
                        playerNames: { [user.uid]: user.displayName || user.email.split('@')[0] },
                        playerDecks: { [user.uid]: selectedDeck },
                        createdAt: window.Date.now(),
                        active: true,
                        phase: null,
                        startingPlayer: null,
                        currentTurn: null,
                        gameState: {},
                        gameResult: null,
                        showMulliganSummary: false,
                        mulliganSummaryConfirmed: {},
                    });
                    setCurrentRoomId(newRoomId);
                    setView('game');
                } catch (error) {
                    console.error("Error creating room:", error);
                    alert("Fehler beim Erstellen des Raums. Bitte versuchen Sie es erneut.");
                }
            };
            
            const joinRoom = async (roomId) => {
                if (!selectedDeck) {
                    alert("Please select a deck first.");
                    return;
                }
                const room = rooms.find(r => r.id === roomId);
                if (!room || room.players.length >= 2 || room.emptyAt) {
                    alert("Der Raum wurde nicht gefunden oder bereits voll. Bitte aktualisieren Sie die Seite.");
                    return;
                }

                try {
                    const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                    await window.updateDoc(roomRef, { 
                        players: [...room.players, user.uid], 
                        playerNames: { ...room.playerNames, [user.uid]: user.displayName || user.email.split('@')[0] },
                        playerDecks: { ...room.playerDecks, [user.uid]: selectedDeck },
                        emptyAt: null 
                    });
                    setCurrentRoomId(roomId);
                    setView('game');
                } catch (error) {
                    console.error("Error joining room:", error);
                    alert("Fehler beim Beitreten des Raums. Bitte versuchen Sie es erneut.");
                }
            };

            const deleteRoom = async (roomId, e) => {
                e.stopPropagation();
                if(!confirm("Delete room?")) return;
                await window.deleteDoc(window.doc(window.getPublicRoomCollection(), roomId));
            };
            
            const clearMyRooms = async () => {
                if(!confirm("Close ALL your rooms?")) return;
                const q = window.query(window.getPublicRoomCollection(), window.where('host', '==', user.uid));
                const snapshot = await window.getDocs(q);
                snapshot.forEach(doc => {
                    window.deleteDoc(window.doc(window.getPublicRoomCollection(), doc.id));
                });
            };

            if (view === 'game' && currentRoomId && selectedDeck) {
                return <GameSim deck={selectedDeck} onLeave={() => { setView('lobby'); setCurrentRoomId(null); }} roomId={currentRoomId} />;
            }
            
            // LOBBY VIEW
            return (
                <div className="h-full flex flex-col">
                    <Header user={user} selectedDeck={selectedDeck} />
                    <div className="flex-grow overflow-y-auto p-6 max-w-7xl mx-auto w-full">
                        
                        <h2 className="text-3xl font-bold text-white mb-6">Commander Arena Lobby</h2>

                        {/* Deck Selection & Actions */}
                        <div className="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 mb-8">
                            <h3 className="text-xl font-bold text-yellow-400 mb-4">Your Deck</h3>
                            <div className="flex flex-col md:flex-row gap-6">
                                <div className="flex-grow">
                                    <label className="block text-sm font-medium text-gray-400 mb-2">Select Deck to Play With:</label>
                                    <select 
                                        value={selectedDeck?.id || ''} 
                                        onChange={(e) => setSelectedDeck(decks.find(d => d.id === e.target.value))} 
                                        className="w-full bg-gray-700 border border-gray-600 p-3 rounded text-white"
                                    >
                                        <option value="" disabled>-- Select your Commander Deck --</option>
                                        {decks.map(deck => (
                                            <option key={deck.id} value={deck.id}>{deck.name} ({deck.cards.length} cards)</option>
                                        ))}
                                    </select>
                                </div>
                                <div className="flex flex-col space-y-2 md:space-y-0 md:flex-row md:space-x-4 md:items-end">
                                    <button 
                                        onClick={() => window.location.href = 'builder.html'} 
                                        className="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-colors flex items-center justify-center space-x-2"
                                    >
                                        <i data-lucide="edit" className="w-5 h-5"></i>
                                        <span>Deck Builder</span>
                                    </button>
                                    <button 
                                        onClick={createRoom} 
                                        disabled={!selectedDeck}
                                        className="bg-green-600 hover:bg-green-500 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-3 px-6 rounded-lg shadow-md transition-colors flex items-center justify-center space-x-2"
                                    >
                                        <i data-lucide="play" className="w-5 h-5"></i>
                                        <span>Create New Game</span>
                                    </button>
                                </div>
                            </div>
                        </div>

                        {/* Room List */}
                        <div className="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-2xl font-bold text-yellow-400">Available Rooms</h2>
                                <button onClick={clearMyRooms} className="bg-red-600 hover:bg-red-500 text-white py-2 px-4 rounded text-sm font-bold shadow-md">
                                     Close My Rooms
                                </button>
                            </div>
                            <div className="space-y-3">
                                {rooms.filter(r => r.players.length < 2 || r.players.includes(user.uid)).map(room => (
                                    <div key={room.id} className={`bg-gray-900/50 p-4 rounded-lg border flex justify-between items-center transition-all ${room.emptyAt ? 'border-red-500/50 bg-red-900/10' : 'border-gray-700 hover:border-blue-500'}`}>
                                        <div className="flex-grow">
                                            <h3 className={`font-bold ${room.players.includes(user.uid) ? 'text-blue-400' : 'text-white'}`}>
                                                {room.host === user.uid ? 'Your Room' : `${room.hostName}'s Room`}
                                                {room.players.includes(user.uid) && <span className="text-xs text-blue-400 ml-2">(Joined)</span>}
                                            </h3>
                                            {room.emptyAt ? (
                                                <div className="flex items-center space-x-2 mt-1">
                                                    <span className="text-red-400 text-sm font-bold">Closing:</span>
                                                    <RoomTimer emptyAt={room.emptyAt} />
                                                </div>
                                            ) : (
                                                <p className="text-sm text-gray-400">{room.players.length}/2 players</p>
                                            )}
                                        </div>
                                        <div className="flex items-center space-x-2">
                                            {room.host === user.uid ? (
                                                <button onClick={(e) => deleteRoom(room.id, e)} className="bg-red-600 hover:bg-red-500 text-white p-2 rounded" title="Delete my room">
                                                    <i data-lucide="trash" className="w-5 h-5"></i>
                                                </button>
                                            ) : (
                                                <button 
                                                    onClick={() => joinRoom(room.id)} 
                                                    disabled={!selectedDeck || !!room.emptyAt || room.players.length >= 2} 
                                                    className={`px-4 py-2 rounded text-white font-bold transition-colors ${!selectedDeck || !!room.emptyAt || room.players.length >= 2
                                                        ? 'bg-gray-600 cursor-not-allowed'
                                                        : 'bg-blue-600 hover:bg-blue-500'}`}
                                                >
                                                    Join Game
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                ))}
                                {rooms.filter(r => r.players.length < 2).length === 0 && (
                                    <p className="text-gray-500 text-center py-4">No open rooms available. Create a new one!</p>
                                )}
                            </div>
                        </div>
                        
                        <div className="h-10"></div> {/* Spacer for bottom */}
                    </div>
                </div>
            );
        };
        
        // Render lucide icons after React components are rendered
        useEffect(() => {
            window.lucide.createIcons();
        }, []);


    </script>
</body>
</html>
