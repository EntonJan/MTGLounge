<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arena - MTG Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: { 
                extend: { 
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: { mtg: { w: '#F9F3B7', u: '#3A62B7', b: '#1E1E1E', r: '#D64242', g: '#5B9567' } }
                } 
            }
        }
    </script>
    <style>
        /* Strict Viewport Locking */
        body, html { height: 100%; width: 100%; overflow: hidden; margin: 0; padding: 0; overscroll-behavior: none; }
        body { background-color: #111827; color: #e5e5e5; font-family: 'Inter', sans-serif; position: fixed; inset: 0; }
        
        .glass { background: rgba(31, 41, 55, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .card-shadow { box-shadow: -2px 2px 8px rgba(0,0,0,0.5); }
        .tapped { transform: rotate(90deg); transition: transform 0.2s ease; }
        .untapped { transform: rotate(0deg); transition: transform 0.2s ease; }
        
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #eab308; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-900">

    <div id="app-root" class="h-full w-full">
        <div class="h-full flex flex-col items-center justify-center">
            <div class="loader mb-4"></div>
            <p class="text-gray-400">Connecting to Arena...</p>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDocs, deleteDoc, onSnapshot, addDoc, updateDoc, query, where } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyB2qmkKq4sYOXDd7mF-Mq1rnCWCfDAWXew",
            authDomain: "entons-game-tracker.firebaseapp.com",
            projectId: "entons-game-tracker",
            storageBucket: "entons-game-tracker.firebasestorage.app",
            messagingSenderId: "968932411080",
            appId: "1:968932411080:web:d391ffe5ecbd7852bc47fd",
            measurementId: "G-KB6JSFEPS1"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        window.db = db;
        window.auth = auth;
        window.signOut = signOut;
        window.updateProfile = updateProfile;
        window.collection = collection;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.onSnapshot = onSnapshot;
        window.addDoc = addDoc;
        window.updateDoc = updateDoc;
        window.query = query;
        window.where = where;
        window.getPublicRoomCollection = () => collection(db, 'arena_rooms');

        const renderAuthCheck = () => {
             onAuthStateChanged(auth, (user) => {
                const rootElement = document.getElementById('app-root');
                if (user) {
                    window.currentUser = user;
                    if (typeof App !== 'undefined') {
                        const root = ReactDOM.createRoot(rootElement);
                        root.render(React.createElement(App, { user: user })); 
                    } else {
                        setTimeout(() => {
                            if (typeof App !== 'undefined') {
                                const root = ReactDOM.createRoot(rootElement);
                                root.render(React.createElement(App, { user: user }));
                            }
                        }, 500);
                    }
                } else {
                    window.location.href = 'index.html';
                }
            });
        };

        window.onload = renderAuthCheck;
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const generateId = () => Math.random().toString(36).substring(2, 9);

        const Header = ({ user, selectedDeck, roomCreatedAt }) => {
            const displayName = user.displayName || user.email.split('@')[0];
            const [timeString, setTimeString] = useState("00:00");

            useEffect(() => {
                if (!roomCreatedAt) return;
                const interval = setInterval(() => {
                    const now = Date.now();
                    const diff = Math.floor((now - roomCreatedAt) / 1000);
                    const m = Math.floor(diff / 60).toString().padStart(2, '0');
                    const s = (diff % 60).toString().padStart(2, '0');
                    setTimeString(`${m}:${s}`);
                }, 1000);
                return () => clearInterval(interval);
            }, [roomCreatedAt]);

            return (
                <header className="bg-gray-800 shadow-md p-2 flex-shrink-0 border-b border-gray-700 z-50 relative h-[60px] flex items-center justify-between box-border">
                    <div className="flex items-center space-x-2 md:space-x-4">
                        <h1 className="text-xl md:text-2xl font-bold text-red-400">Arena</h1>
                        <button onClick={() => window.location.href = 'homescreen.html'} className="bg-gray-700 p-1.5 rounded-full text-white"><i data-lucide="home" className="w-4 h-4"></i></button>
                        {roomCreatedAt && <div className="bg-black/50 px-2 py-1 rounded text-yellow-400 font-mono text-sm border border-yellow-500/30">{timeString}</div>}
                    </div>
                    {selectedDeck && (
                        <div className="hidden md:flex flex-col items-center absolute left-1/2 transform -translate-x-1/2">
                             <span className="text-[10px] text-gray-500 uppercase tracking-widest font-semibold">Playing With</span>
                             <span className="text-yellow-400 font-bold leading-none">{selectedDeck.name}</span>
                        </div>
                    )}
                    <div className="text-right text-xs md:text-sm flex flex-col items-end">
                         <span className="font-semibold text-white truncate max-w-[100px]">{displayName}</span>
                         <button onClick={() => window.signOut(window.auth).then(() => window.location.href = 'index.html')} className="text-red-400 hover:text-red-300 flex items-center mt-0.5">Logout</button>
                    </div>
                </header>
            );
        };

        const CardImage = ({ src, alt, className, style, onClick, onContextMenu, onMouseEnter, onMouseLeave, isBack = false }) => {
            const imageSrc = isBack ? 'https://upload.wikimedia.org/wikipedia/en/a/aa/Magic_the_gathering-card_back.jpg' : src;
            return (
                <div 
                    className={`relative rounded-lg overflow-hidden bg-gray-800 ${className}`} 
                    style={style}
                    onClick={onClick}
                    onContextMenu={onContextMenu}
                    onMouseEnter={onMouseEnter}
                    onMouseLeave={onMouseLeave}
                >
                    <img src={imageSrc} alt={alt || 'Card'} className="w-full h-full object-contain select-none pointer-events-none" />
                </div>
            );
        };

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className="bg-gray-800 border border-gray-600 rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-gray-700">
                            <h3 className="text-xl font-bold text-yellow-400">{title}</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-white"><i data-lucide="x" className="w-6 h-6"></i></button>
                        </div>
                        <div className="p-4 overflow-y-auto flex-grow">{children}</div>
                    </div>
                </div>
            );
        };

        const ContextMenu = ({ x, y, options, onClose }) => (
            <div className="fixed z-[200] bg-gray-800 border border-gray-600 rounded shadow-xl py-1 min-w-[150px]" style={{ left: x, top: y }} onMouseLeave={onClose}>
                {options.map((opt, i) => (
                    <button key={i} onClick={() => { opt.action(); onClose(); }} className="block w-full text-left px-4 py-2 text-sm text-white hover:bg-gray-700">{opt.label}</button>
                ))}
            </div>
        );
        
        const GameSim = ({ deck, onLeave, roomId }) => {
            const [roomState, setRoomState] = useState(null);
            const [loading, setLoading] = useState(true);
            const [opponentMaximized, setOpponentMaximized] = useState(false);
            const [viewingZone, setViewingZone] = useState(null); 
            const [draggedCard, setDraggedCard] = useState(null);
            const [hoveredCard, setHoveredCard] = useState(null);
            const [libraryMenu, setLibraryMenu] = useState(null);
            const [topCardView, setTopCardView] = useState(null);
            const [isHandMinimized, setIsHandMinimized] = useState(false);
            const [leaveGameModal, setLeaveGameModal] = useState(false);
            const [gameResult, setGameResult] = useState({ winner: '', confirmed: false });

            const playerLowerBattlefieldRef = useRef(null);
            const playerUpperBattlefieldRef = useRef(null);
            const initializingRef = useRef(false);
            const hasInitializedRef = useRef(false);

            const user = window.currentUser;

            // --- Dynamic Heights ---
            // Header is 60px fixed. Total viewport is 100vh.
            // Available space = 100vh - 60px.
            // Split: Opponent Area (Top) ~15%, Battlefield Upper ~25%, Battlefield Lower ~40%, Hand ~20%
            // But we need explicit pixels or vh for calculation.
            // Let's stick to vh but account for header.
            const HEADER_H = '60px';
            const GAME_H = `calc(100vh - ${HEADER_H})`;
            const handHeight = isHandMinimized ? '40px' : '150px';
            
            // Zones logic:
            const opponentZoneH = '120px'; // Top strip
            const fieldAvailableH = `calc(100vh - ${HEADER_H} - ${opponentZoneH} - ${handHeight})`;
            
            // Divide field into Upper (Lands/Ench) and Lower (Creatures)
            const fieldUpperH = `calc(${fieldAvailableH} * 0.4)`;
            const fieldLowerH = `calc(${fieldAvailableH} * 0.6)`;
            
            const sidebarTop = `calc(${HEADER_H} + ${opponentZoneH} + ${fieldUpperH})`;
            const sidebarH = fieldLowerH;

            useEffect(() => {
                const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                const unsubscribe = window.onSnapshot(roomRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        setRoomState(data);
                        setLoading(false);
                        if (data.gameResult && !data.gameResult.confirmed && data.gameResult.submittedBy !== user.uid) {
                            setGameResult(data.gameResult);
                            setLeaveGameModal(true);
                        }
                    } else { onLeave(); }
                });
                return () => unsubscribe();
            }, [roomId]);

            useEffect(() => {
                if (loading || !roomState) return;
                const myId = user.uid;
                if (roomState.gameState && roomState.gameState[myId]) { hasInitializedRef.current = true; return; }
                if (initializingRef.current || hasInitializedRef.current) return;
                initializingRef.current = true;
                
                const initLibrary = deck.cards.map(c => ({ ...c, instanceId: generateId(), isTapped: false }));
                for (let i = initLibrary.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [initLibrary[i], initLibrary[j]] = [initLibrary[j], initLibrary[i]];
                }
                const startingHand = initLibrary.splice(0, 7);
                const commander = deck.commander ? [{ ...deck.commander, instanceId: generateId(), isTapped: false, isCommander: true }] : [];

                const initialPlayerState = {
                    life: 40, commanderDamage: 0, cmdTax: 0,
                    library: initLibrary, hand: startingHand, 
                    battlefieldUpper: [], battlefieldLower: [],
                    graveyard: [], exile: [], commandZone: commander
                };

                window.setDoc(window.doc(window.getPublicRoomCollection(), roomId), {
                    gameState: { [myId]: initialPlayerState }
                }, { merge: true })
                .then(() => { hasInitializedRef.current = true; initializingRef.current = false; })
                .catch(e => { initializingRef.current = false; });
            }, [roomState, deck, loading]);

            useEffect(() => { lucide.createIcons(); }, [roomState, opponentMaximized, viewingZone, leaveGameModal, isHandMinimized]);

            const myState = roomState?.gameState?.[user.uid];
            const opponentId = roomState?.players?.find(p => p !== user.uid);
            const opponentState = roomState?.gameState?.[opponentId];

            if (loading || !myState) return <div className="h-full flex flex-col items-center justify-center text-yellow-400"><div className="loader mb-4"></div><p>Syncing...</p></div>;

            const updateMyState = (updates) => {
                const updatePayload = {};
                Object.keys(updates).forEach(key => { updatePayload[`gameState.${user.uid}.${key}`] = updates[key]; });
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), updatePayload);
            };

            const drawCard = () => {
                if (myState.library.length === 0) return;
                const newLib = [...myState.library];
                const card = newLib.shift();
                updateMyState({ library: newLib, hand: [...myState.hand, card] });
            };

            const shuffleLibrary = () => {
                const newLib = [...myState.library];
                for (let i = newLib.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newLib[i], newLib[j]] = [newLib[j], newLib[i]]; }
                updateMyState({ library: newLib });
            };

            const playCard = (card, fromZone, targetBattlefield, coords = null) => {
                const newCard = { ...card, isTapped: false, x: coords?.x ?? (Math.random() * 200 + 50), y: coords?.y ?? (Math.random() * 200 + 50) };
                let updates = {};
                if (targetBattlefield === 'upper') updates.battlefieldUpper = [...(myState.battlefieldUpper || []), newCard];
                else updates.battlefieldLower = [...(myState.battlefieldLower || []), newCard];
                
                const filter = c => c.instanceId !== card.instanceId;
                if (fromZone === 'hand') updates.hand = myState.hand.filter(filter);
                else if (fromZone === 'command') { updates.commandZone = myState.commandZone.filter(filter); updates.cmdTax = (myState.cmdTax || 0) + 2; }
                else if (fromZone === 'graveyard') updates.graveyard = myState.graveyard.filter(filter);
                else if (fromZone === 'exile') updates.exile = myState.exile.filter(filter);
                else if (fromZone === 'library_top') updates.library = myState.library.filter(filter);
                
                updateMyState(updates);
            };

            const moveCardToZone = (card, toZone) => {
                const filter = c => c.instanceId !== card.instanceId;
                let updates = {
                    battlefieldUpper: (myState.battlefieldUpper || []).filter(filter),
                    battlefieldLower: (myState.battlefieldLower || []).filter(filter),
                    hand: myState.hand.filter(filter),
                    graveyard: myState.graveyard.filter(filter),
                    exile: myState.exile.filter(filter),
                    commandZone: myState.commandZone.filter(filter),
                    library: myState.library.filter(filter)
                };
                if (toZone === 'graveyard') updates.graveyard = [card, ...updates.graveyard];
                else if (toZone === 'exile') updates.exile = [card, ...updates.exile];
                else if (toZone === 'hand') updates.hand = [...updates.hand, card];
                else if (toZone === 'command') updates.commandZone = [card, ...updates.commandZone];
                else if (toZone === 'library_top') updates.library = [card, ...updates.library];
                else if (toZone === 'library_bottom') updates.library = [...updates.library, card];
                updateMyState(updates);
            };

            const toggleTap = (id, battlefield) => {
                const key = battlefield === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                const bf = (myState[key] || []).map(c => c.instanceId === id ? { ...c, isTapped: !c.isTapped } : c);
                updateMyState({ [key]: bf });
            };

            const handleDragStart = (e, card, fromZone) => setDraggedCard({ card, fromZone });
            
            const handleDropOnBattlefield = (e, targetBattlefield, battlefieldRef) => {
                e.preventDefault();
                if (!draggedCard) return;
                const rect = battlefieldRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left - 45; // Center card
                const y = e.clientY - rect.top - 60;

                if (draggedCard.fromZone === 'battlefieldUpper' || draggedCard.fromZone === 'battlefieldLower') {
                    const updates = {};
                    updates.battlefieldUpper = (myState.battlefieldUpper || []).filter(c => c.instanceId !== draggedCard.card.instanceId);
                    updates.battlefieldLower = (myState.battlefieldLower || []).filter(c => c.instanceId !== draggedCard.card.instanceId);
                    const movedCard = { ...draggedCard.card, x, y };
                    if (targetBattlefield === 'upper') updates.battlefieldUpper = [...updates.battlefieldUpper, movedCard];
                    else updates.battlefieldLower = [...updates.battlefieldLower, movedCard];
                    updateMyState(updates);
                } else {
                    playCard(draggedCard.card, draggedCard.fromZone, targetBattlefield, { x, y });
                }
                setDraggedCard(null);
            };

            const handleDropOnZone = (e, zone) => {
                e.preventDefault();
                if (!draggedCard) return;
                const target = zone === 'library' ? 'library_top' : zone;
                if (draggedCard.fromZone === target) { setDraggedCard(null); return; }
                moveCardToZone(draggedCard.card, target);
                setDraggedCard(null);
            };

            return (
                <div className="w-full relative bg-gray-900 overflow-hidden flex flex-col" style={{ height: GAME_H }}>
                    
                    {hoveredCard && <div className="fixed top-20 right-4 z-[100] pointer-events-none w-64 h-[350px] rounded-xl overflow-hidden shadow-2xl border-2 border-yellow-500 bg-black"><img src={hoveredCard} className="w-full h-full object-contain" /></div>}
                    
                    {libraryMenu && <ContextMenu x={libraryMenu.x} y={libraryMenu.y} onClose={() => setLibraryMenu(null)} options={[{ label: 'Draw', action: drawCard }, { label: 'Top Card', action: () => { if(myState.library.length>0) setTopCardView(myState.library[0]); } }, { label: 'Shuffle', action: shuffleLibrary }]} />}

                    {topCardView && <Modal isOpen={true} onClose={() => setTopCardView(null)} title="Top of Library"><div className="flex flex-col items-center gap-4"><img src={topCardView.image_url} className="w-48 rounded-xl shadow-lg" /><div className="flex gap-4"><button onClick={() => { setTopCardView(null); }} className="bg-blue-600 px-4 py-2 rounded text-white">Keep</button><button onClick={() => { moveCardToZone(topCardView, 'library_bottom'); setTopCardView(null); }} className="bg-yellow-600 px-4 py-2 rounded text-white">Bottom</button><button onClick={() => { playCard(topCardView, 'library_top', 'lower'); setTopCardView(null); }} className="bg-green-600 px-4 py-2 rounded text-white">Play</button></div></div></Modal>}

                    {leaveGameModal && <Modal isOpen={true} onClose={() => setLeaveGameModal(false)} title="Game Result"><div className="flex flex-col items-center gap-4"><p className="text-white text-lg">Who won?</p><div className="flex gap-4"><button onClick={async () => { await window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), { gameResult: { winner: user.uid, submittedBy: user.uid, confirmed: false } }); }} className="bg-green-600 px-6 py-3 rounded text-white">I Won</button><button onClick={() => setLeaveGameModal(false)} className="bg-gray-600 px-6 py-3 rounded text-white">Cancel</button></div></div></Modal>}

                    {/* --- OPPONENT ZONE --- */}
                    <div style={{ height: opponentZoneH }} className="w-full relative bg-red-900/10 border-b border-red-500/30 flex justify-center items-center">
                         {opponentState ? (
                             <div className="flex items-center gap-4">
                                 <div className="flex flex-col items-center"><span className="text-xs text-red-400">Hand</span><div className="flex -space-x-8">{Array(Math.min(opponentState.hand?.length||0,7)).fill(0).map((_,i)=><CardImage key={i} isBack={true} className="w-10 h-14 border border-gray-600" />)}</div></div>
                                 <div className="flex flex-col items-center text-sm"><span className="text-red-300">Life: {opponentState.life}</span></div>
                                 <div className="flex flex-col items-center"><span className="text-xs text-red-400">Grave</span>{opponentState.graveyard?.[0] && <CardImage src={opponentState.graveyard[0].image_url} className="w-10 h-14" />}</div>
                             </div>
                         ) : <span className="text-gray-500">Waiting for opponent...</span>}
                    </div>

                    {/* --- BATTLEFIELD UPPER (Your Lands/Ench) --- */}
                    <div style={{ height: fieldUpperH }} className="w-full relative bg-blue-900/10 border-b border-blue-500/30">
                        <div ref={playerUpperBattlefieldRef} className="h-full w-full relative" onDrop={(e) => handleDropOnBattlefield(e, 'upper', playerUpperBattlefieldRef)} onDragOver={(e) => e.preventDefault()}>
                            {(myState.battlefieldUpper || []).map(card => (
                                <div key={card.instanceId} className="absolute cursor-pointer" style={{ left: card.x, top: card.y }} draggable onDragStart={(e) => handleDragStart(e, card, 'battlefieldUpper')}>
                                    <CardImage src={card.image_url} className={`w-[80px] h-[110px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`} onClick={() => toggleTap(card.instanceId, 'upper')} onMouseEnter={() => setHoveredCard(card.image_url)} onMouseLeave={() => setHoveredCard(null)} />
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* --- BATTLEFIELD LOWER (Creatures) --- */}
                    <div style={{ height: fieldLowerH, position: 'relative' }} className="w-full bg-blue-900/20 border-b border-blue-500/30">
                         {/* Sidebars (Left/Right) within this zone */}
                         <div className="absolute left-0 top-0 bottom-0 w-40 z-10 bg-gray-900/50 p-2 flex flex-col gap-2 overflow-y-auto">
                            <div className="bg-blue-900/80 p-2 rounded text-xs">
                                <div className="flex justify-between"><span>Life:</span><span className="text-green-400 font-bold">{myState.life}</span></div>
                                <div className="flex gap-1 mt-1"><button onClick={() => updateMyState({ life: myState.life + 1 })} className="bg-green-600 flex-1 rounded">+</button><button onClick={() => updateMyState({ life: myState.life - 1 })} className="bg-red-600 flex-1 rounded">-</button></div>
                            </div>
                            <div className="bg-blue-900/80 p-2 rounded flex-1 overflow-y-auto" onDrop={(e) => handleDropOnZone(e, 'command')} onDragOver={(e) => e.preventDefault()}>
                                <span className="text-xs text-blue-300 block mb-1">Command</span>
                                {myState.commandZone.map(c => <div key={c.instanceId} draggable onDragStart={(e)=>handleDragStart(e,c,'command')}><CardImage src={c.image_url} className="w-full mb-1" /></div>)}
                            </div>
                            <button onClick={onLeave} className="bg-red-600 text-xs py-1 rounded w-full">Leave</button>
                         </div>

                         <div className="absolute right-0 top-0 bottom-0 w-32 z-10 bg-gray-900/50 p-2 flex flex-col gap-2">
                             <div className="bg-blue-900/80 p-2 rounded text-center cursor-pointer" onClick={(e) => setLibraryMenu({ x: e.clientX, y: e.clientY })}><span className="text-xs">Lib ({myState.library.length})</span><CardImage isBack={true} className="w-16 mx-auto mt-1 h-20" /></div>
                             <div className="bg-blue-900/80 p-2 rounded text-center" onDrop={(e) => handleDropOnZone(e, 'graveyard')} onDragOver={(e) => e.preventDefault()} onClick={() => setViewingZone('graveyard')}><span className="text-xs">Grave ({myState.graveyard.length})</span>{myState.graveyard[0] ? <CardImage src={myState.graveyard[0].image_url} className="w-16 mx-auto mt-1 h-20" /> : <div className="w-16 h-20 border border-gray-600 mx-auto mt-1"></div>}</div>
                             <div className="bg-blue-900/80 p-2 rounded text-center" onDrop={(e) => handleDropOnZone(e, 'exile')} onDragOver={(e) => e.preventDefault()} onClick={() => setViewingZone('exile')}><span className="text-xs">Exile ({myState.exile.length})</span>{myState.exile[0] ? <CardImage src={myState.exile[0].image_url} className="w-16 mx-auto mt-1 h-20" /> : <div className="w-16 h-20 border border-gray-600 mx-auto mt-1"></div>}</div>
                         </div>

                        <div ref={playerLowerBattlefieldRef} className="h-full absolute left-40 right-32 top-0" onDrop={(e) => handleDropOnBattlefield(e, 'lower', playerLowerBattlefieldRef)} onDragOver={(e) => e.preventDefault()}>
                            {(myState.battlefieldLower || []).map(card => (
                                <div key={card.instanceId} className="absolute cursor-pointer" style={{ left: card.x, top: card.y }} draggable onDragStart={(e) => handleDragStart(e, card, 'battlefieldLower')}>
                                    <CardImage src={card.image_url} className={`w-[80px] h-[110px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`} onClick={() => toggleTap(card.instanceId, 'lower')} onMouseEnter={() => setHoveredCard(card.image_url)} onMouseLeave={() => setHoveredCard(null)} />
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* --- HAND --- */}
                    <div style={{ height: handHeight }} className="w-full relative z-20 bg-gray-900 border-t border-gray-700 transition-all duration-300" onDrop={(e) => handleDropOnZone(e, 'hand')} onDragOver={(e) => e.preventDefault()}>
                        <button onClick={() => setIsHandMinimized(!isHandMinimized)} className="absolute -top-3 left-1/2 transform -translate-x-1/2 bg-gray-700 rounded-full w-8 h-4 flex items-center justify-center border border-gray-600"><div className="w-4 h-1 bg-gray-400 rounded"></div></button>
                        {!isHandMinimized && (
                            <div className="flex gap-2 p-2 items-center h-full overflow-x-auto scrollbar-hide">
                                {myState.hand.map(card => (
                                    <div key={card.instanceId} draggable onDragStart={(e) => handleDragStart(e, card, 'hand')} className="flex-shrink-0 cursor-pointer hover:-translate-y-4 transition-transform">
                                        <CardImage src={card.image_url} className="w-[100px] h-[140px] rounded-lg shadow-lg" onMouseEnter={() => setHoveredCard(card.image_url)} onMouseLeave={() => setHoveredCard(null)} />
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const App = ({ user }) => {
            const [view, setView] = useState('lobby');
            const [selectedDeck, setSelectedDeck] = useState(null);
            const [decks, setDecks] = useState([]);
            const [rooms, setRooms] = useState([]);
            const [currentRoomId, setCurrentRoomId] = useState(null);

            useEffect(() => {
                const loadDecks = async () => {
                    const deckCollection = window.collection(window.db, 'users', user.uid, 'decks');
                    const snapshot = await window.getDocs(deckCollection);
                    setDecks(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
                };
                loadDecks();
                const unsubscribe = window.onSnapshot(window.getPublicRoomCollection(), (snapshot) => {
                    setRooms(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
                });
                return () => unsubscribe();
            }, []);

            useEffect(() => { lucide.createIcons(); }, [view, rooms, decks]);

            const createRoom = async () => {
                if (!selectedDeck) { alert("Select a deck first"); return; }
                const roomRef = await window.addDoc(window.getPublicRoomCollection(), {
                    host: user.uid, hostName: user.displayName || user.email.split('@')[0],
                    players: [user.uid], createdAt: Date.now(), gameState: {}
                });
                setCurrentRoomId(roomRef.id);
                setView('game');
            };

            const joinRoom = async (roomId) => {
                if (!selectedDeck) { alert("Select a deck first"); return; }
                const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                await window.updateDoc(roomRef, { players: [rooms.find(r => r.id === roomId).players[0], user.uid] });
                setCurrentRoomId(roomId);
                setView('game');
            };

            const leaveGame = () => { setView('lobby'); setCurrentRoomId(null); };

            if (view === 'game' && currentRoomId && selectedDeck) {
                const room = rooms.find(r => r.id === currentRoomId);
                return <><Header user={user} selectedDeck={selectedDeck} roomCreatedAt={room?.createdAt} /><GameSim deck={selectedDeck} onLeave={leaveGame} roomId={currentRoomId} /></>;
            }

            return (
                <div className="h-full flex flex-col bg-gray-900 overflow-hidden">
                    <Header user={user} selectedDeck={selectedDeck} />
                    <div className="flex-grow p-4 md:p-8 overflow-y-auto">
                        <div className="max-w-6xl mx-auto">
                            <div className="mb-6">
                                <h2 className="text-3xl font-bold text-yellow-400 mb-4">Select Your Deck</h2>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    {decks.map(deck => (
                                        <div key={deck.id} onClick={() => setSelectedDeck(deck)} className={`p-4 rounded-lg cursor-pointer border ${selectedDeck?.id === deck.id ? 'bg-yellow-600 border-yellow-400' : 'bg-gray-800 border-gray-700 hover:border-yellow-500'}`}>
                                            <h3 className="font-bold text-white">{deck.name}</h3><p className="text-sm text-gray-400">{deck.cards?.length || 0} cards</p>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                                <div><h2 className="text-2xl font-bold text-yellow-400 mb-4">Create Room</h2><button onClick={createRoom} disabled={!selectedDeck} className="w-full bg-green-600 hover:bg-green-500 disabled:bg-gray-600 text-white font-bold py-4 px-6 rounded-lg">Create New Room</button></div>
                                <div>
                                    <h2 className="text-2xl font-bold text-yellow-400 mb-4">Available Rooms</h2>
                                    <div className="space-y-2">{rooms.filter(r => r.players.length < 2).map(room => (
                                        <div key={room.id} className="bg-gray-800 p-4 rounded-lg border border-gray-700 flex justify-between items-center">
                                            <div><h3 className="font-bold text-white">{room.hostName}'s Room</h3></div>
                                            {room.host !== user.uid && <button onClick={() => joinRoom(room.id)} disabled={!selectedDeck} className="bg-blue-600 text-white px-4 py-2 rounded">Join</button>}
                                        </div>
                                    ))}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
    </script>
</body>
</html>