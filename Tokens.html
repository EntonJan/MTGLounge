<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena - MTG Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: { 
                extend: { 
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: {
                        mtg: {
                            w: '#F9F3B7', u: '#3A62B7', b: '#1E1E1E', r: '#D64242', g: '#5B9567'
                        }
                    }
                } 
            }
        }
    </script>
    <style>
        body { background-color: #111827; color: #e5e5e5; font-family: 'Inter', sans-serif; overflow: hidden; }
        .glass { background: rgba(31, 41, 55, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .glass-dark { background: rgba(17, 24, 39, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .card-shadow { box-shadow: -2px 2px 8px rgba(0,0,0,0.5); }
        .tapped { transform: rotate(90deg); transition: transform 0.2s ease; }
        .untapped { transform: rotate(0deg); transition: transform 0.2s ease; }
        
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #eab308; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .coin-spin { animation: flip 1s ease-out; }
        @keyframes flip { 0% { transform: rotateY(0); } 100% { transform: rotateY(720deg); } }
        
        @keyframes pulse-turn { 0%, 100% { box-shadow: 0 0 10px rgba(34, 197, 94, 0.5); border-color: rgba(34, 197, 94, 0.8); } 50% { box-shadow: 0 0 20px rgba(34, 197, 94, 0.8); border-color: rgba(34, 197, 94, 1); } }
        .active-turn { animation: pulse-turn 2s infinite; }

        @keyframes pulse-turn-opp { 0%, 100% { box-shadow: 0 0 10px rgba(239, 68, 68, 0.5); border-color: rgba(239, 68, 68, 0.8); } 50% { box-shadow: 0 0 20px rgba(239, 68, 68, 0.8); border-color: rgba(239, 68, 68, 1); } }
        .active-turn-opp { animation: pulse-turn-opp 2s infinite; }

        .counter-badge { text-shadow: 0 1px 2px rgba(0,0,0,0.8); box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
    </style>
</head>
<body class="h-screen w-screen bg-gray-900 overflow-hidden">

    <div id="app-root" class="h-full w-full">
        <div class="h-full flex flex-col items-center justify-center">
            <div class="loader mb-4"></div>
            <p class="text-gray-400">Connecting to Arena...</p>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDocs, deleteDoc, onSnapshot, addDoc, updateDoc, query, where } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyB2qmkKq4sYOXDd7mF-Mq1rnCWCfDAWXew",
            authDomain: "entons-game-tracker.firebaseapp.com",
            projectId: "entons-game-tracker",
            storageBucket: "entons-game-tracker.firebasestorage.app",
            messagingSenderId: "968932411080",
            appId: "1:968932411080:web:d391ffe5ecbd7852bc47fd",
            measurementId: "G-KB6JSFEPS1"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        window.db = db;
        window.auth = auth;
        window.signOut = signOut;
        window.updateProfile = updateProfile;
        window.currentUser = null;
        window.collection = collection;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.onSnapshot = onSnapshot;
        window.addDoc = addDoc;
        window.updateDoc = updateDoc;
        window.query = query;
        window.where = where;
        window.getPublicRoomCollection = () => collection(db, 'arena_rooms');

        const renderAuthCheck = () => {
             onAuthStateChanged(auth, (user) => {
                const rootElement = document.getElementById('app-root');
                if (user) {
                    window.currentUser = user;
                    if (typeof App !== 'undefined') {
                        const root = ReactDOM.createRoot(rootElement);
                        root.render(React.createElement(App, { user: user })); 
                    } else {
                        setTimeout(() => {
                            if (typeof App !== 'undefined') {
                                const root = ReactDOM.createRoot(rootElement);
                                root.render(React.createElement(App, { user: user }));
                            }
                        }, 100);
                    }
                } else {
                    window.location.href = 'index.html';
                }
            });
        };

        window.onload = renderAuthCheck;
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const generateId = () => Math.random().toString(36).substring(2, 9);
        const ROOM_TIMEOUT_MS = 180000; 

        // --- CONSTANTS WITH REAL IMAGES ---
        const COMMON_TOKENS = [
            { name: 'Treasure', type: 'Artifact Token', image: 'https://cards.scryfall.io/large/front/6/e/6e84d47b-83f8-41f4-90f9-81335b8f2f53.jpg' },
            { name: 'Food', type: 'Artifact Token', image: 'https://cards.scryfall.io/large/front/b/f/bf36408d-ed85-497f-8e68-d3a922c388a0.jpg' },
            { name: 'Clue', type: 'Artifact Token', image: 'https://cards.scryfall.io/large/front/0/0/0088de00-d310-4c08-a56f-e085a6791f42.jpg' },
            { name: 'Soldier (1/1)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/7/3/73c1b01c-d766-41f2-9861-12502b0cffb3.jpg' },
            { name: 'Goblin (1/1)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/b/d/bd08c2a3-f9a8-406b-a2c2-b5b155f3408c.jpg' },
            { name: 'Zombie (2/2)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/8/e/8e5e1e07-f316-43c1-8f9f-7d1a5c6ca801.jpg' },
            { name: 'Angel (4/4)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/f/e/fe261e68-0e86-444a-b14a-11e0f06795f0.jpg' },
            { name: 'Elf Warrior (1/1)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/9/d/9dd015b6-4b61-41e3-a4c8-479c094af7d2.jpg' },
            { name: 'Dragon (5/5)', type: 'Creature Token', image: 'https://cards.scryfall.io/large/front/8/c/8c7827e8-4228-4f1b-a45e-5b12163b784a.jpg' },
            { name: 'Copy', type: 'Token', image: 'https://cards.scryfall.io/large/front/4/f/4f4931ce-18f3-4fac-b8c7-99ea78f4019a.jpg' }
        ];

        const COUNTER_TYPES = [
            { label: '+1/+1', color: 'bg-green-600', short: '+1' },
            { label: '-1/-1', color: 'bg-red-600', short: '-1' },
            { label: 'Flying', color: 'bg-blue-500', short: 'Fly' },
            { label: 'Lifelink', color: 'bg-pink-600', short: 'Life' },
            { label: 'Trample', color: 'bg-orange-600', short: 'Trpl' },
            { label: 'Vigilance', color: 'bg-gray-500', short: 'Vigi' },
            { label: 'Haste', color: 'bg-red-500', short: 'Hst' },
            { label: 'Hexproof', color: 'bg-purple-600', short: 'Hex' },
            { label: 'Indestructible', color: 'bg-yellow-600', short: 'Ind' },
            { label: 'Shield', color: 'bg-cyan-500', short: 'Shld' }
        ];

        const COLOR_DATA = [
            { id: 'W', hex: '#F9F3B7', bg: 'bg-yellow-100', text: 'text-yellow-900', label: 'White' },
            { id: 'U', hex: '#3A62B7', bg: 'bg-blue-600', text: 'text-white', label: 'Blue' },
            { id: 'B', hex: '#1E1E1E', bg: 'bg-gray-900', text: 'text-white', label: 'Black' },
            { id: 'R', hex: '#D64242', bg: 'bg-red-600', text: 'text-white', label: 'Red' },
            { id: 'G', hex: '#5B9567', bg: 'bg-green-600', text: 'text-white', label: 'Green' }
        ];

        const Header = ({ user, selectedDeck }) => {
            const displayName = user.displayName || user.email.split('@')[0];
            const hexId = user.uid.substring(0, 9).toUpperCase();

            return (
                <header className="bg-gray-800 shadow-md p-4 flex-shrink-0 border-b border-gray-700 z-50 relative">
                    <div className="max-w-7xl mx-auto flex justify-between items-center h-full">
                        <div className="flex items-center space-x-4">
                            <h1 className="text-2xl font-bold text-red-400 tracking-tight">Arena</h1>
                            <button onClick={() => window.location.href = 'homescreen.html'} className="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-full transition-colors shadow-sm" title="Home Menu">
                                <i data-lucide="home" className="w-5 h-5"></i>
                            </button>
                        </div>
                        {selectedDeck && (
                            <div className="hidden md:flex flex-col items-center absolute left-1/2 transform -translate-x-1/2">
                                 <span className="text-[10px] text-gray-500 uppercase tracking-widest font-semibold">Playing With</span>
                                 <span className="text-yellow-400 font-bold text-lg leading-none">{selectedDeck.name}</span>
                            </div>
                        )}
                        <div className="text-right text-sm">
                            <div className="flex items-center justify-end space-x-2">
                                 <span className="font-semibold text-white cursor-pointer hover:text-red-300" onClick={async () => {
                                     const newName = prompt(`Enter new display name:`);
                                     if (newName && newName.trim()) {
                                         try { await window.updateProfile(user, { displayName: newName.trim() }); window.location.reload(); } catch(e) {}
                                     }
                                 }}>{displayName}</span>
                                 <span className="text-gray-500">| {hexId}</span>
                            </div>
                             <div className="flex items-center justify-end space-x-2 mt-1">
                                <span className="text-xs text-gray-500">{user.email}</span>
                                <button onClick={() => window.signOut(window.auth).then(() => window.location.href = 'index.html')} className="text-red-400 hover:text-red-300 text-xs flex items-center">
                                    <i data-lucide="log-out" className="w-3 h-3 mr-1"></i> Logout
                                </button>
                            </div>
                        </div>
                    </div>
                </header>
            );
        };

        const CardImage = ({ src, alt, className, style, onClick, onContextMenu, onMouseEnter, onMouseLeave, isBack = false, counters = [] }) => {
            const imageSrc = isBack ? 'https://upload.wikimedia.org/wikipedia/en/a/aa/Magic_the_gathering-card_back.jpg' : src;
            return (
                <div 
                    className={`relative rounded-lg overflow-visible bg-gray-800 ${className}`} 
                    style={style}
                    onClick={onClick}
                    onContextMenu={onContextMenu}
                    onMouseEnter={onMouseEnter}
                    onMouseLeave={onMouseLeave}
                >
                    <div className="rounded-lg overflow-hidden w-full h-full relative">
                        <img src={imageSrc} alt={alt || 'Card Back'} className="w-full h-full object-cover select-none pointer-events-none" />
                        {!isBack && <div className="absolute inset-0 bg-gradient-to-tr from-transparent via-white/5 to-white/10 pointer-events-none"></div>}
                    </div>
                    
                    {counters && counters.length > 0 && (
                        <div className="absolute -top-2 -right-2 flex flex-col items-end gap-1 z-20 pointer-events-none">
                            {counters.map((c, i) => (
                                <span key={i} className={`${c.color} text-white text-[10px] font-bold px-1.5 py-0.5 rounded-full counter-badge border border-white/20`}>
                                    {c.short}
                                </span>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className="bg-gray-800 border border-gray-600 rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-gray-700">
                            <h3 className="text-xl font-bold text-yellow-400">{title}</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-white">
                                <i data-lucide="x" className="w-6 h-6"></i>
                            </button>
                        </div>
                        <div className="p-4 overflow-y-auto flex-grow">
                            {children}
                        </div>
                    </div>
                </div>
            );
        };

        const ContextMenu = ({ x, y, options, onClose }) => {
            const style = { left: x, top: y };
            if (y > window.innerHeight - 200) { style.top = 'auto'; style.bottom = window.innerHeight - y; }
            if (x > window.innerWidth - 200) { style.left = 'auto'; style.right = window.innerWidth - x; }

            return (
                <div className="fixed z-[200] bg-gray-800 border border-gray-600 rounded shadow-xl py-1 min-w-[160px]" style={style} onMouseLeave={onClose}>
                    {options.map((opt, i) => {
                        if (opt.divider) return <div key={i} className="h-px bg-gray-700 my-1"></div>;
                        if (opt.header) return <div key={i} className="px-4 py-1 text-xs font-bold text-gray-500 uppercase">{opt.header}</div>;
                        return (
                            <button key={i} onClick={() => { opt.action(); onClose(); }} className="block w-full text-left px-4 py-2 text-sm text-white hover:bg-gray-700 flex items-center justify-between group">
                                <span>{opt.label}</span>
                                {opt.rightIcon && <span className="text-gray-400 group-hover:text-white">{opt.rightIcon}</span>}
                            </button>
                        );
                    })}
                </div>
            );
        };

        const Coin = () => (
            <div className="w-6 h-6 rounded-full bg-gradient-to-br from-yellow-300 to-yellow-600 border border-yellow-700 flex items-center justify-center shadow-lg coin-spin mx-2" title="Starting Player">
                <span className="text-yellow-900 font-bold text-xs">1</span>
            </div>
        );

        const GameSim = ({ deck, onLeave, roomId }) => {
            const [roomState, setRoomState] = useState(null);
            const [loading, setLoading] = useState(true);
            const [viewingZone, setViewingZone] = useState(null); 
            const [draggedCard, setDraggedCard] = useState(null);
            const [hoveredCard, setHoveredCard] = useState(null);
            const [libraryMenu, setLibraryMenu] = useState(null);
            const [topCardView, setTopCardView] = useState(null);
            const [myHandMinimized, setMyHandMinimized] = useState(false);
            const [oppHandMinimized, setOppHandMinimized] = useState(false);
            const [cardContextMenu, setCardContextMenu] = useState(null);
            
            // Replaced toolsMenuOpen with TokenSelectorModal logic
            const [tokenSelectorModalOpen, setTokenSelectorModalOpen] = useState(false);
            const [tokenTab, setTokenTab] = useState('common'); // 'common' or 'custom'
            const [customTokenData, setCustomTokenData] = useState({ name: '', power: '1', toughness: '1', colors: { W:false, U:false, B:false, R:false, G:false }, imageUrl: '' });

            const [leaveGameModal, setLeaveGameModal] = useState(false);
            const [mulliganSummaryModal, setMulliganSummaryModal] = useState(false);
            const [gameResult, setGameResult] = useState({ winner: '', confirmed: false });

            const playerLowerBattlefieldRef = useRef(null);
            const playerUpperBattlefieldRef = useRef(null);
            const initializingRef = useRef(false);
            const hasInitializedRef = useRef(false);

            const user = window.currentUser;
            const db = window.db;

            // Sync Room
            useEffect(() => {
                const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                const unsubscribe = window.onSnapshot(roomRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        setRoomState(data);
                        setLoading(false);
                        
                        // Game Result Modal
                        if (data.gameResult && !data.gameResult.confirmed && data.gameResult.submittedBy !== user.uid) {
                            setGameResult(data.gameResult); setLeaveGameModal(true);
                        }
                        
                        // Mulligan Summary Modal trigger
                        if (data.showMulliganSummary && !data.mulliganSummaryConfirmed?.[user.uid]) {
                            setMulliganSummaryModal(true);
                        }
                    } else { onLeave(); }
                });
                return () => unsubscribe();
            }, [roomId]);

            // Host Init (Starting Player & Phase)
            useEffect(() => {
                if (!loading && roomState && roomState.host === user.uid && roomState.players.length === 2) {
                    const updates = {};
                    if (!roomState.startingPlayer) {
                        const starter = Math.random() < 0.5 ? roomState.players[0] : roomState.players[1];
                        updates.startingPlayer = starter;
                        updates.currentTurn = starter; 
                    }
                    if (!roomState.phase) {
                        updates.phase = 'mulligan';
                    }
                    if (Object.keys(updates).length > 0) {
                         window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), updates);
                    }
                }
            }, [roomState, loading, user.uid, roomId]);

            // Player Init
            useEffect(() => {
                if (loading || !roomState) return;
                const myId = user.uid;
                if (roomState.gameState && roomState.gameState[myId]) { hasInitializedRef.current = true; return; }
                if (initializingRef.current || hasInitializedRef.current) return;
                initializingRef.current = true;
                
                // *** DEFENSIVE CHECK FOR DECK ***
                if (!deck || !deck.cards) {
                    console.error("Deck is missing or invalid!", deck);
                    initializingRef.current = false; 
                    return; 
                }

                const initLibrary = deck.cards.map(c => ({ ...c, instanceId: generateId(), isTapped: false, counters: [] }));
                for (let i = initLibrary.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [initLibrary[i], initLibrary[j]] = [initLibrary[j], initLibrary[i]]; }
                const startingHand = initLibrary.splice(0, 7);
                const commander = deck.commander ? [{ ...deck.commander, instanceId: generateId(), isTapped: false, isCommander: true, counters: [] }] : [];

                const initialPlayerState = { life: 40, commanderDamage: 0, cmdTax: 0, mulliganCount: 0, library: initLibrary, hand: startingHand, battlefieldUpper: [], battlefieldLower: [], graveyard: [], exile: [], commandZone: commander };
                window.setDoc(window.doc(window.getPublicRoomCollection(), roomId), { gameState: { [myId]: initialPlayerState } }, { merge: true })
                .then(() => { hasInitializedRef.current = true; initializingRef.current = false; })
                .catch(e => { initializingRef.current = false; });
            }, [roomState, deck, loading]);

            useEffect(() => { lucide.createIcons(); }, [roomState, viewingZone, leaveGameModal, myHandMinimized, oppHandMinimized, tokenSelectorModalOpen, mulliganSummaryModal]);

            const myState = roomState?.gameState?.[user.uid];
            const opponentId = roomState?.players?.find(p => p !== user.uid);
            const opponentState = roomState?.gameState?.[opponentId];
            
            // *** FIX: More defensive loading check ***
            // This waits for `myState` to be an object AND for `myState.hand` to be initialized.
            if (loading || !myState || !myState.hand) {
                return <div className="h-full flex flex-col items-center justify-center text-yellow-400"><div className="loader mb-4"></div><p>Syncing...</p></div>;
            }

            const opponentName = roomState?.players?.find(p => p !== user.uid) === roomState?.host ? roomState?.hostName : 'Opponent';
            const startingPlayerId = roomState?.startingPlayer;
            const currentTurnId = roomState?.currentTurn;
            const phase = roomState?.phase || 'mulligan';

            const isMyTurn = currentTurnId === user.uid;
            // This line is now safe because the guard check above ensures `myState.hand` exists
            const showMulligan = phase === 'mulligan' && myState.hand.length > 0;

            const updateMyState = (updates) => {
                const updatePayload = {}; Object.keys(updates).forEach(key => { updatePayload[`gameState.${user.uid}.${key}`] = updates[key]; });
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), updatePayload);
            };

            const drawCard = () => { 
                if (myState.library.length === 0) return; 
                if (phase === 'mulligan' && user.uid === startingPlayerId) {
                    window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), { phase: 'game', showMulliganSummary: true });
                }
                const newLib = [...myState.library]; const card = newLib.shift(); 
                updateMyState({ library: newLib, hand: [...myState.hand, card] }); 
            };

            const shuffleLibrary = () => { const newLib = [...myState.library]; for (let i = newLib.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newLib[i], newLib[j]] = [newLib[j], newLib[i]]; } updateMyState({ library: newLib }); };
            
            const mulligan = () => { 
                if (myState.hand.length === 0 && myState.library.length < 7) return; 
                let newLib = [...myState.library, ...myState.hand]; 
                for (let i = newLib.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newLib[i], newLib[j]] = [newLib[j], newLib[i]]; } 
                const newHand = newLib.splice(0, myState.hand.length - 1); // Draw one less card
                updateMyState({ 
                    library: newLib, 
                    hand: newHand, 
                    mulliganCount: (myState.mulliganCount || 0) + 1 
                }); 
            };
            
            const keepHand = () => {
                if (phase === 'mulligan') {
                    if (user.uid === startingPlayerId) {
                         window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), { phase: 'game', showMulliganSummary: true });
                    } else {
                        // Non-starting player keeps hand, they must wait for starting player's first draw
                        if (roomState.phase === 'mulligan') {
                             window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), { [`gameState.${user.uid}.handKept`]: true });
                        }
                    }
                }
            };
            
            const playCard = (card, fromZone, toBattlefield, position = {}) => {
                const newCard = { ...card, x: position.x || 100, y: position.y || 100, isTapped: false, counters: [] };
                let updates = {};
                
                if (toBattlefield === 'upper') updates.battlefieldUpper = [...(myState.battlefieldUpper || []), newCard];
                else updates.battlefieldLower = [...(myState.battlefieldLower || []), newCard];

                if (fromZone === 'hand') updates.hand = myState.hand.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'command') {
                    updates.commandZone = myState.commandZone.filter(c => c.instanceId !== card.instanceId);
                    updates.cmdTax = (myState.cmdTax || 0) + 2;
                }
                else if (fromZone === 'graveyard') updates.graveyard = myState.graveyard.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'exile') updates.exile = myState.exile.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'library_top' || fromZone === 'library') updates.library = myState.library.filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'battlefieldUpper') updates.battlefieldUpper = (myState.battlefieldUpper || []).filter(c => c.instanceId !== card.instanceId);
                else if (fromZone === 'battlefieldLower') updates.battlefieldLower = (myState.battlefieldLower || []).filter(c => c.instanceId !== card.instanceId);
                
                updateMyState(updates);
            };

            const moveCardToZone = (card, toZone) => {
                const filter = c => c.instanceId !== card.instanceId;
                let updates = { 
                    battlefieldUpper: (myState.battlefieldUpper || []).filter(filter), 
                    battlefieldLower: (myState.battlefieldLower || []).filter(filter), 
                    hand: (myState.hand || []).filter(filter), 
                    graveyard: (myState.graveyard || []).filter(filter), 
                    exile: (myState.exile || []).filter(filter), 
                    commandZone: (myState.commandZone || []).filter(filter),
                    library: (myState.library || []).filter(filter)
                };
                
                const cardWithoutPosition = { ...card, x: undefined, y: undefined, isTapped: false, counters: card.isCommander ? card.counters : [] }; 

                if (toZone === 'library_top') updates.library = [cardWithoutPosition, ...updates.library];
                else if (toZone === 'library_bottom') updates.library = [...updates.library, cardWithoutPosition];
                else if (toZone === 'hand') updates.hand = [...updates.hand, cardWithoutPosition];
                else if (toZone === 'graveyard') updates.graveyard = [...updates.graveyard, cardWithoutPosition];
                else if (toZone === 'exile') updates.exile = [...updates.exile, cardWithoutPosition];
                else if (toZone === 'command') {
                    updates.commandZone = [...updates.commandZone.filter(c => c.instanceId !== card.instanceId), cardWithoutPosition];
                    if (!card.isCommander) updates.cmdTax = (myState.cmdTax || 0) + 2; 
                }

                updateMyState(updates);
            };
            
            const createToken = (tokenData) => {
                const newToken = { 
                    ...tokenData, 
                    instanceId: generateId(), 
                    x: 100, 
                    y: 100, 
                    isToken: true, 
                    isTapped: false, 
                    counters: [] 
                };
                updateMyState({ battlefieldLower: [...(myState.battlefieldLower || []), newToken] });
            };

            const createCustomToken = () => {
                const { name, power, toughness, colors, imageUrl } = customTokenData;
                let finalImage = imageUrl;

                if (!finalImage) {
                    const colorIds = Object.keys(colors).filter(id => colors[id]);
                    const selectedColors = COLOR_DATA.filter(c => colorIds.includes(c.id));
                    
                    let bgColorHex = selectedColors.length > 0 ? selectedColors[0].hex.substring(1) : '374151'; // Default: gray-700
                    let textColorHex = selectedColors.length > 0 && selectedColors[0].id === 'W' ? '1f2937' : 'ffffff'; // Default: white

                    // Simple background color blending (for multi-color) - this is complex, so let's just use the first color
                    if (selectedColors.length > 1) {
                         bgColorHex = '1f2937'; // Black/Gray
                         textColorHex = 'ffffff'; 
                    } else if (selectedColors.length === 1) {
                        bgColorHex = selectedColors[0].hex.substring(1);
                        textColorHex = selectedColors[0].id === 'W' ? '1f2937' : 'ffffff';
                    }

                    const stats = power && toughness ? `${power}/${toughness}` : '';
                    const displayName = name || 'Token';
                    const text = `${displayName}\n${stats}`;
                    finalImage = `https://placehold.co/400x560/${bgColorHex}/${textColorHex}.png?text=${encodeURIComponent(text)}`;
                }

                createToken({ name: name || 'Token', type: 'Token', image: finalImage });
                setCustomTokenData({ name: '', power: '1', toughness: '1', colors: { W:false, U:false, B:false, R:false, G:false }, imageUrl: '' });
            };

            const updateCardCounters = (card, counterType, battlefieldZone) => {
                const zoneKey = battlefieldZone === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                const currentCards = myState[zoneKey] || [];
                const updatedCards = currentCards.map(c => c.instanceId !== card.instanceId ? c : { ...c, counters: [...(c.counters || []), counterType] });
                updateMyState({ [zoneKey]: updatedCards });
            };

            const removeCounter = (card, index, battlefieldZone) => {
                const zoneKey = battlefieldZone === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';
                const currentCards = myState[zoneKey] || [];
                const updatedCards = currentCards.map(c => {
                    if (c.instanceId !== card.instanceId) return c;
                    const newCounters = [...(c.counters || [])];
                    newCounters.splice(index, 1);
                    return { ...c, counters: newCounters };
                });
                updateMyState({ [zoneKey]: updatedCards });
            };

            const toggleTap = (id, battlefield) => {
                if (battlefield === 'upper') {
                    const updatedCards = myState.battlefieldUpper.map(card => 
                        card.instanceId === id ? { ...card, isTapped: !card.isTapped } : card
                    );
                    updateMyState({ battlefieldUpper: updatedCards });
                } else {
                    const updatedCards = myState.battlefieldLower.map(card => 
                        card.instanceId === id ? { ...card, isTapped: !card.isTapped } : card
                    );
                    updateMyState({ battlefieldLower: updatedCards });
                }
            };
            
            const handleDragStart = (e, card, fromZone) => {
                setDraggedCard({ card, fromZone, offsetX: e.clientX - e.currentTarget.getBoundingClientRect().left, offsetY: e.clientY - e.currentTarget.getBoundingClientRect().top });
            };

            const handleDragOver = (e) => { e.preventDefault(); };

            const handleDropOnBattlefield = (e, targetBattlefield) => {
                e.preventDefault();
                if (!draggedCard) return;

                const targetRef = targetBattlefield === 'upper' ? playerUpperBattlefieldRef : playerLowerBattlefieldRef;
                if (!targetRef.current) { setDraggedCard(null); return; }

                const bounds = targetRef.current.getBoundingClientRect();
                const cardWidth = 90; 
                const cardHeight = 120;
                
                let x = e.clientX - bounds.left - draggedCard.offsetX;
                let y = e.clientY - bounds.top - draggedCard.offsetY;
                
                // Keep card fully within bounds
                x = Math.max(0, Math.min(x, bounds.width - cardWidth));
                y = Math.max(0, Math.min(y, bounds.height - cardHeight));

                if (draggedCard.fromZone.startsWith('battlefield')) {
                    // Update position if moving between zones or within the same zone
                    const updates = { battlefieldUpper: [...(myState.battlefieldUpper || [])], battlefieldLower: [...(myState.battlefieldLower || [])] };
                    const sourceKey = draggedCard.fromZone === 'battlefieldUpper' ? 'battlefieldUpper' : 'battlefieldLower';
                    const targetKey = targetBattlefield === 'upper' ? 'battlefieldUpper' : 'battlefieldLower';

                    const cardIndex = updates[sourceKey].findIndex(c => c.instanceId === draggedCard.card.instanceId);
                    if (cardIndex !== -1) {
                        const [movedCard] = updates[sourceKey].splice(cardIndex, 1);
                        movedCard.x = x;
                        movedCard.y = y;
                        movedCard.isTapped = false; // Untap when moving zones/repositioning
                        
                        if (targetBattlefield === 'upper') updates.battlefieldUpper = [...updates.battlefieldUpper, movedCard];
                        else updates.battlefieldLower = [...updates.battlefieldLower, movedCard];
                        
                        updateMyState(updates);
                    }
                } else {
                    playCard(draggedCard.card, draggedCard.fromZone, targetBattlefield, { x, y });
                }
                
                setDraggedCard(null);
            };

            const handleDropOnZone = (e, zone) => {
                e.preventDefault();
                if (!draggedCard) return;
                
                const target = zone === 'library' ? 'library_top' : zone;

                if (draggedCard.fromZone === target) { setDraggedCard(null); return; }
                
                moveCardToZone(draggedCard.card, target);
                setDraggedCard(null);
            };

            const openCardContextMenu = (e, card, zone) => {
                e.preventDefault();
                e.stopPropagation();

                const options = [
                    { header: 'Card Actions' },
                    { label: card.isTapped ? 'Untap' : 'Tap', action: () => toggleTap(card.instanceId, zone === 'battlefieldUpper' ? 'upper' : 'lower') },
                    { label: 'To Hand', action: () => moveCardToZone(card, 'hand') },
                    { label: 'To Graveyard', action: () => moveCardToZone(card, 'graveyard') },
                    { label: 'To Exile', action: () => moveCardToZone(card, 'exile') },
                    { label: 'To Command Zone', action: () => moveCardToZone(card, 'command') },
                    { divider: true },
                    { header: 'Counters' }
                ];

                COUNTER_TYPES.forEach(ct => {
                    options.push({ 
                        label: `Add ${ct.label}`, 
                        action: () => updateCardCounters(card, ct, zone === 'battlefieldUpper' ? 'upper' : 'lower'),
                        rightIcon: <span className={`w-3 h-3 rounded-full ${ct.color} inline-block`}></span>
                    });
                });
                
                if (card.counters && card.counters.length > 0) {
                    options.push({ divider: true });
                    options.push({ label: 'Remove Counter', header: 'Remove Counter' });
                    card.counters.forEach((ct, index) => {
                        options.push({ 
                            label: ` - ${ct.label}`, 
                            action: () => removeCounter(card, index, zone === 'battlefieldUpper' ? 'upper' : 'lower')
                        });
                    });
                }

                setCardContextMenu({ x: e.clientX, y: e.clientY, options: options });
            };
            
            const passTurn = () => {
                if (currentTurnId !== user.uid) return;
                const nextPlayerId = opponentId;
                // Untap all my tapped cards
                const untapCards = (cards) => cards.map(c => ({ ...c, isTapped: false }));
                const updates = { 
                    currentTurn: nextPlayerId,
                    [`gameState.${user.uid}.battlefieldUpper`]: untapCards(myState.battlefieldUpper || []),
                    [`gameState.${user.uid}.battlefieldLower`]: untapCards(myState.battlefieldLower || []),
                    [`gameState.${opponentId}.handKept`]: undefined // Reset opponent's mulligan status
                };
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), updates);
            };

            const submitGameResult = (winnerId) => {
                const result = { winner: winnerId, submittedBy: user.uid, confirmed: false };
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), { gameResult: result });
                setGameResult(result);
                setLeaveGameModal(true);
            };

            const confirmGameResult = async () => {
                if (gameResult.winner && gameResult.submittedBy !== user.uid) {
                    await window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), { 'gameResult.confirmed': true });
                    setLeaveGameModal(false);
                    onLeave();
                } else if (gameResult.submittedBy === user.uid) {
                    // Host submitted, waiting for opponent. Just close the modal for now.
                    setLeaveGameModal(false); 
                }
            };
            
            const disputeGameResult = async () => {
                await window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), { gameResult: null });
                setGameResult({ winner: '', confirmed: false });
                setLeaveGameModal(false);
            };

            const confirmMulliganSummary = () => {
                const updates = { [`mulliganSummaryConfirmed.${user.uid}`]: true };
                // If both players confirmed, remove the flag
                const otherPlayerConfirmed = roomState.mulliganSummaryConfirmed?.[opponentId];
                if (otherPlayerConfirmed) updates.showMulliganSummary = false;
                
                window.updateDoc(window.doc(window.getPublicRoomCollection(), roomId), updates);
                setMulliganSummaryModal(false);
            };


            return (
                <div className="h-full flex flex-col relative overflow-hidden bg-gray-900">
                    <Header user={user} selectedDeck={deck} />

                    {/* --- MAIN GAME ARENA --- */}
                    <main className="flex-grow relative overflow-hidden bg-gray-900">
                        {/* Opponent's Hand */}
                        <div className={`absolute top-0 left-0 right-0 z-10 p-2 transition-all duration-300 ${oppHandMinimized ? 'h-8' : 'h-32'}`}>
                            {oppHandMinimized ? (
                                <button onClick={() => setOppHandMinimized(false)} className="bg-red-900/90 backdrop-blur-sm px-4 py-1 rounded-b-lg border border-red-500/50 text-red-400 font-bold text-xs shadow-lg hover:bg-red-800 transition-colors">Maximize Opponent Hand ({opponentState.hand.length})</button>
                            ) : (
                                <div className="bg-red-900/90 backdrop-blur-sm px-4 py-2 rounded-b-lg border-b border-x border-red-500/50 relative group shadow-xl max-w-[95vw] mx-auto flex overflow-x-auto scrollbar-hide" onDrop={(e) => handleDropOnZone(e, 'opponent_hand')} onDragOver={(e) => e.preventDefault()}>
                                    <button onClick={() => setOppHandMinimized(true)} className="absolute bottom-0 right-0 p-1 text-red-400 opacity-50 hover:opacity-100 transition-opacity">
                                        <i data-lucide="minimize-2" className="w-4 h-4"></i>
                                    </button>
                                    <h4 className="text-red-400 font-bold text-sm mr-4 flex-shrink-0">Opponent's Hand ({opponentState.hand.length})</h4>
                                    <div className="flex gap-2">
                                        {opponentState.hand.map((card, index) => (
                                            <CardImage 
                                                key={card.instanceId} 
                                                src={card.image_url} 
                                                className="w-16 h-20 flex-shrink-0 card-shadow" 
                                                isBack={true}
                                                onMouseEnter={() => setHoveredCard(card.image_url)} 
                                                onMouseLeave={() => setHoveredCard(null)} 
                                            />
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        {/* Opponent's Battlefield (Upper) - Drag target */}
                        <div 
                            ref={playerUpperBattlefieldRef}
                            className="absolute top-32 left-0 right-0 h-[calc(50%-8rem)] border-b border-dashed border-gray-700 bg-gray-800/10 transition-all duration-300"
                            onDragOver={handleDragOver}
                            onDrop={(e) => handleDropOnBattlefield(e, 'upper')}
                        >
                             {(myState.battlefieldUpper || []).map(card => (
                                <div 
                                    key={card.instanceId} 
                                    className="absolute cursor-pointer" 
                                    style={{ left: card.x, top: card.y }}
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, card, 'battlefieldUpper')}
                                    onContextMenu={(e) => openCardContextMenu(e, card, 'battlefieldUpper')}
                                >
                                    <CardImage 
                                        src={card.image_url} 
                                        counters={card.counters}
                                        className={`w-[90px] h-[120px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`}
                                        onClick={() => toggleTap(card.instanceId, 'upper')}
                                        onMouseEnter={() => setHoveredCard(card.image_url)} 
                                        onMouseLeave={() => setHoveredCard(null)} 
                                    />
                                </div>
                            ))}
                        </div>
                        
                        {/* Player's Battlefield (Lower) - Drag target */}
                        <div 
                            ref={playerLowerBattlefieldRef}
                            className="absolute bottom-32 left-0 right-0 h-[calc(50%-8rem)] bg-gray-800/10 transition-all duration-300"
                            onDragOver={handleDragOver}
                            onDrop={(e) => handleDropOnBattlefield(e, 'lower')}
                        >
                            {(myState.battlefieldLower || []).map(card => (
                                <div 
                                    key={card.instanceId} 
                                    className="absolute cursor-pointer" 
                                    style={{ left: card.x, top: card.y }}
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, card, 'battlefieldLower')}
                                    onContextMenu={(e) => openCardContextMenu(e, card, 'battlefieldLower')}
                                >
                                    <CardImage 
                                        src={card.image_url} 
                                        counters={card.counters}
                                        className={`w-[90px] h-[120px] card-shadow ${card.isTapped ? 'tapped' : 'untapped'}`}
                                        onClick={() => toggleTap(card.instanceId, 'lower')}
                                        onMouseEnter={() => setHoveredCard(card.image_url)} 
                                        onMouseLeave={() => setHoveredCard(null)} 
                                    />
                                </div>
                            ))}
                        </div>

                        {/* --- PLAYER UI --- */}
                        <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 z-50 flex flex-col items-center">
                            {isMyTurn && (
                                <button onClick={passTurn} className="mb-2 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-2 px-6 rounded-full shadow-lg border-2 border-yellow-400 animate-bounce">
                                    Pass Turn
                                </button>
                            )}
                            
                            {/* My Hand */}
                            {myHandMinimized ? (
                                <button onClick={() => setMyHandMinimized(false)} className="bg-blue-900/90 backdrop-blur-sm px-4 py-1 rounded-t-lg border border-blue-500/50 text-blue-400 font-bold text-xs shadow-lg hover:bg-blue-800 transition-colors">Maximize Hand</button>
                            ) : (
                                <div className="bg-blue-900/90 backdrop-blur-sm px-4 py-2 rounded-t-lg border-t border-x border-blue-500/50 relative group shadow-xl max-w-[95vw]" onDrop={(e) => handleDropOnZone(e, 'hand')} onDragOver={(e) => e.preventDefault()}>
                                    <button onClick={() => setMyHandMinimized(true)} className="absolute top-0 right-0 p-1 text-blue-400 opacity-50 hover:opacity-100 transition-opacity">
                                        <i data-lucide="minimize-2" className="w-4 h-4"></i>
                                    </button>
                                    <h4 className="text-blue-400 font-bold text-sm mb-2 flex-shrink-0">My Hand ({myState.hand.length})</h4>
                                    
                                    {/* Mulligan Overlay */}
                                    {showMulligan && (
                                        <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center p-4 rounded-t-lg z-50">
                                            <p className="text-yellow-400 font-bold mb-2 text-lg">Mulligan?</p>
                                            <p className="text-sm text-gray-300 mb-4">You have {7 - myState.hand.length} cards in hand ({myState.mulliganCount || 0} mulligans)</p>
                                            <div className="flex gap-4">
                                                <button onClick={mulligan} disabled={myState.hand.length === 0} className="bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded font-bold shadow-lg disabled:opacity-50">
                                                    Mulligan ({myState.hand.length - 1} cards)
                                                </button>
                                                <button onClick={keepHand} className="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded font-bold shadow-lg">
                                                    Keep
                                                </button>
                                            </div>
                                        </div>
                                    )}

                                    <div className="flex gap-2 overflow-x-auto scrollbar-hide py-1">
                                        {myState.hand.map((card, index) => (
                                            <div 
                                                key={card.instanceId} 
                                                className="w-16 h-20 flex-shrink-0 cursor-grab" 
                                                draggable 
                                                onDragStart={(e) => handleDragStart(e, card, 'hand')}
                                            >
                                                <CardImage 
                                                    src={card.image_url} 
                                                    className="w-full h-full card-shadow" 
                                                    onMouseEnter={() => setHoveredCard(card.image_url)} 
                                                    onMouseLeave={() => setHoveredCard(null)} 
                                                />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* --- SIDEPANEL (TOOLS & ZONES) --- */}
                        <div className="absolute top-32 right-2 z-40 w-56 flex flex-col gap-2">
                            
                            {/* My Stats & Lifecount */}
                            <div className={`bg-blue-900/80 backdrop-blur-sm p-4 rounded-lg border flex-shrink-0 shadow-lg transition-all duration-500 ${isMyTurn ? 'active-turn border-green-500' : 'border-blue-500/50'}`}>
                                <div className="flex justify-between items-center mb-2">
                                    <h4 className="text-blue-400 text-sm font-bold flex items-center gap-2">
                                        Me {isMyTurn && <span className="bg-green-600 text-white text-[10px] px-2 py-0.5 rounded-full animate-pulse">TURN</span>}
                                    </h4>
                                    {startingPlayerId === user.uid && <Coin />}
                                    <button onClick={() => setLeaveGameModal(true)} className="text-yellow-400 hover:text-yellow-300 text-xs flex items-center">
                                        <i data-lucide="log-out" className="w-4 h-4 mr-1"></i> End Game
                                    </button>
                                </div>
                                <div className="text-white text-sm space-y-1">
                                    <div className="flex items-center justify-between">
                                        <span>Life:</span>
                                        <span className="text-green-400 font-bold text-lg">{myState.life}</span>
                                    </div>
                                    <div className="flex gap-1">
                                        <button onClick={() => updateMyState({ life: myState.life + 1 })} className="flex-1 bg-green-600 px-2 py-1 rounded text-xs hover:bg-green-500">+</button>
                                        <button onClick={() => updateMyState({ life: myState.life - 1 })} className="flex-1 bg-red-600 px-2 py-1 rounded text-xs hover:bg-red-500">-</button>
                                    </div>
                                    
                                    <div className="flex items-center justify-between mt-2">
                                        <span>Cmd Dmg:</span>
                                        <span className="text-red-400 font-bold">{myState.commanderDamage || 0}</span>
                                    </div>
                                     <div className="flex gap-1">
                                        <button onClick={() => { const currentCmdDmg = myState.commanderDamage || 0; updateMyState({ commanderDamage: currentCmdDmg + 1, life: myState.life - 1 }); }} className="flex-1 bg-red-600 px-2 py-1 rounded text-xs hover:bg-red-500">+</button>
                                        <button onClick={() => { const currentCmdDmg = myState.commanderDamage || 0; if (currentCmdDmg > 0) updateMyState({ commanderDamage: currentCmdDmg - 1, life: myState.life + 1 }); }} className="flex-1 bg-green-600 px-2 py-1 rounded text-xs hover:bg-green-500" disabled={!(myState.commanderDamage > 0)}>-</button>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Command Zone */}
                            {myState.commandZone?.length > 0 && (
                                <div className="bg-blue-900/80 backdrop-blur-sm p-3 rounded-lg border border-blue-500/50 overflow-hidden flex flex-col shadow-lg" onDrop={(e) => handleDropOnZone(e, 'command')} onDragOver={(e) => e.preventDefault()}>
                                    <h4 className="text-blue-400 text-sm font-bold mb-2 flex-shrink-0 flex justify-between items-center">
                                        Command Zone
                                        <span className="text-xs text-gray-300">Tax: <span className="text-yellow-400 font-bold">{myState.cmdTax || 0}</span></span>
                                    </h4>
                                    <div className="flex flex-wrap gap-2 content-start">
                                        {myState.commandZone.map(card => (
                                            <div key={card.instanceId} className="flex flex-col items-center">
                                                <div 
                                                    className="cursor-grab" 
                                                    draggable 
                                                    onDragStart={(e) => handleDragStart(e, card, 'command')}
                                                >
                                                    <CardImage 
                                                        src={card.image_url} 
                                                        className="w-12 h-16 border border-yellow-500 flex-shrink-0 card-shadow" 
                                                        onMouseEnter={() => setHoveredCard(card.image_url)} 
                                                        onMouseLeave={() => setHoveredCard(null)} 
                                                    />
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Tools & Tokens */}
                             <div className="bg-gray-800/80 backdrop-blur-sm p-3 rounded-lg border border-gray-600 shadow-lg flex flex-col gap-2">
                                <h4 className="text-white text-sm font-bold flex-shrink-0">Tools & Tokens</h4>
                                <div className="flex gap-2">
                                    <button onClick={() => setTokenSelectorModalOpen(true)} className="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white px-3 py-2 rounded text-xs font-bold shadow-lg">Create Token</button>
                                    <button onClick={() => alert('WIP: Dice Roll / Coin Flip')} className="flex-1 bg-purple-600 hover:bg-purple-500 text-white px-3 py-2 rounded text-xs font-bold shadow-lg">Dice / Coin</button>
                                </div>
                            </div>

                            {/* Graveyard / Exile / Library */}
                            <div className="bg-gray-800/80 backdrop-blur-sm p-3 rounded-lg border border-gray-600 shadow-lg flex flex-col gap-2">
                                <h4 className="text-white text-sm font-bold flex-shrink-0">Zones</h4>
                                <div className="flex gap-2">
                                    <div 
                                        className="flex-1 bg-gray-700/50 rounded p-2 text-center relative hover:bg-gray-700 transition-colors cursor-pointer"
                                        onClick={() => setViewingZone('graveyard')}
                                        onDrop={(e) => handleDropOnZone(e, 'graveyard')} 
                                        onDragOver={(e) => e.preventDefault()}
                                    >
                                        <h5 className="text-xs text-gray-400">Graveyard</h5>
                                        <p className="text-lg font-bold text-gray-200">{myState.graveyard.length}</p>
                                    </div>
                                    <div 
                                        className="flex-1 bg-gray-700/50 rounded p-2 text-center relative hover:bg-gray-700 transition-colors cursor-pointer"
                                        onClick={() => setViewingZone('exile')}
                                        onDrop={(e) => handleDropOnZone(e, 'exile')} 
                                        onDragOver={(e) => e.preventDefault()}
                                    >
                                        <h5 className="text-xs text-gray-400">Exile</h5>
                                        <p className="text-lg font-bold text-gray-200">{myState.exile.length}</p>
                                    </div>
                                </div>
                                <div 
                                    className="bg-gray-700/50 rounded p-2 text-center relative hover:bg-gray-700 transition-colors"
                                    onClick={(e) => setLibraryMenu({ x: e.clientX, y: e.clientY })}
                                    onContextMenu={(e) => { e.preventDefault(); setLibraryMenu({ x: e.clientX, y: e.clientY }); }}
                                    onDrop={(e) => handleDropOnZone(e, 'library')} 
                                    onDragOver={(e) => e.preventDefault()}
                                >
                                    <h5 className="text-xs text-gray-400">Library</h5>
                                    <p className="text-lg font-bold text-gray-200">{myState.library.length}</p>
                                    <div className="flex gap-2 mt-2">
                                        <button onClick={(e) => { e.stopPropagation(); drawCard(); }} className="flex-1 bg-green-600 hover:bg-green-500 text-white px-3 py-2 rounded text-xs font-bold shadow-lg">Draw</button>
                                        <button onClick={(e) => { e.stopPropagation(); shuffleLibrary(); }} className="flex-1 bg-purple-600 hover:bg-purple-500 text-white px-3 py-2 rounded text-xs font-bold shadow-lg">Shuffle</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* --- OPPONENT SIDEPANEL --- */}
                        <div className="absolute top-4 left-2 z-40 w-56 flex flex-col gap-2 pointer-events-none">
                            <div className={`pointer-events-auto bg-red-900/80 backdrop-blur-sm p-4 rounded-lg border flex-shrink-0 shadow-lg transition-all duration-500 ${currentTurnId === opponentId ? 'active-turn-opp border-red-500' : 'border-red-500/50'}`}>
                                <div className="flex justify-between items-center mb-2">
                                    <h4 className="text-red-400 text-sm font-bold flex items-center gap-2">
                                        {opponentName} {currentTurnId === opponentId && <span className="bg-red-600 text-white text-[10px] px-2 py-0.5 rounded-full animate-pulse">TURN</span>}
                                    </h4>
                                    {startingPlayerId === opponentId && <Coin />}
                                </div>
                                <div className="text-white text-sm space-y-1">
                                    <div>Life: <span className="text-green-400 font-bold text-lg">{opponentState.life}</span></div>
                                    <div>Cmd Dmg: <span className="text-red-400 font-bold">{opponentState.commanderDamage || 0}</span></div>
                                </div>
                            </div>
                            
                            {opponentState.commandZone?.length > 0 && (
                                <div className="pointer-events-auto bg-red-900/80 backdrop-blur-sm p-3 rounded-lg border border-red-500/50 overflow-hidden flex flex-col shadow-lg">
                                    <h4 className="text-red-400 text-sm font-bold mb-2 flex-shrink-0">Command Zone</h4>
                                    <div className="flex flex-wrap gap-2 content-start">
                                        {opponentState.commandZone.map(card => (
                                            <div key={card.instanceId} className="flex flex-col items-center">
                                                <CardImage 
                                                    src={card.image_url} 
                                                    className="w-12 h-16 border border-yellow-500 flex-shrink-0" 
                                                    onMouseEnter={() => setHoveredCard(card.image_url)} 
                                                    onMouseLeave={() => setHoveredCard(null)} 
                                                />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <div className="pointer-events-auto bg-gray-800/80 backdrop-blur-sm p-3 rounded-lg border border-gray-600 shadow-lg flex flex-col gap-2">
                                <h4 className="text-white text-sm font-bold flex-shrink-0">Opponent Zones</h4>
                                <div className="flex gap-2">
                                    <div className="flex-1 bg-gray-700/50 rounded p-2 text-center"><h5 className="text-xs text-gray-400">Graveyard</h5><p className="text-lg font-bold text-gray-200">{opponentState.graveyard.length}</p></div>
                                    <div className="flex-1 bg-gray-700/50 rounded p-2 text-center"><h5 className="text-xs text-gray-400">Exile</h5><p className="text-lg font-bold text-gray-200">{opponentState.exile.length}</p></div>
                                </div>
                                <div className="bg-gray-700/50 rounded p-2 text-center">
                                    <h5 className="text-xs text-gray-400">Library</h5>
                                    <p className="text-lg font-bold text-gray-200">{opponentState.library.length}</p>
                                </div>
                            </div>
                        </div>

                    </main>

                    {/* --- MODALS & CONTEXT MENUS --- */}

                    {/* Token Selector Modal */}
                    <Modal isOpen={tokenSelectorModalOpen} onClose={() => setTokenSelectorModalOpen(false)} title="Create Token">
                        <div className="flex border-b border-gray-700 mb-4">
                            <button onClick={() => setTokenTab('common')} className={`py-2 px-4 text-sm font-semibold transition-colors ${tokenTab === 'common' ? 'text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400 hover:text-white'}`}>
                                Common Tokens
                            </button>
                            <button onClick={() => setTokenTab('custom')} className={`py-2 px-4 text-sm font-semibold transition-colors ${tokenTab === 'custom' ? 'text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400 hover:text-white'}`}>
                                Custom Token
                            </button>
                        </div>

                        {tokenTab === 'common' ? (
                            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
                                {COMMON_TOKENS.map(token => (
                                    <div key={token.name} onClick={() => { createToken(token); setTokenSelectorModalOpen(false); }} className="bg-gray-700 p-2 rounded-lg cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center">
                                        <img src={token.image} className="w-full rounded mb-2 object-cover aspect-[5/7]" />
                                        <span className="text-xs font-bold text-center">{token.name}</span>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Name / Type</label>
                                    <input type="text" value={customTokenData.name} onChange={e => setCustomTokenData({...customTokenData, name: e.target.value})} className="w-full bg-gray-700 border border-gray-600 rounded p-2 text-white" placeholder="e.g. Elf Warrior" />
                                </div>
                                <div className="flex gap-4">
                                    <div className="flex-1">
                                        <label className="block text-sm text-gray-400 mb-1">Power</label>
                                        <input type="text" value={customTokenData.power} onChange={e => setCustomTokenData({...customTokenData, power: e.target.value})} className="w-full bg-gray-700 border border-gray-600 rounded p-2 text-white text-center" />
                                    </div>
                                    <div className="flex-1">
                                        <label className="block text-sm text-gray-400 mb-1">Toughness</label>
                                        <input type="text" value={customTokenData.toughness} onChange={e => setCustomTokenData({...customTokenData, toughness: e.target.value})} className="w-full bg-gray-700 border border-gray-600 rounded p-2 text-white text-center" />
                                    </div>
                                </div>
                                
                                <div>
                                    <label className="block text-sm text-gray-400 mb-2">Colors (Background)</label>
                                    <div className="flex justify-center gap-3">
                                        {COLOR_DATA.map(c => (
                                            <button 
                                                key={c.id} 
                                                onClick={() => setCustomTokenData({ ...customTokenData, colors: { ...customTokenData.colors, [c.id]: !customTokenData.colors[c.id] } })}
                                                className={`w-10 h-10 rounded-full border-2 flex items-center justify-center transition-all ${customTokenData.colors[c.id] ? 'border-white scale-110 shadow-lg' : 'border-gray-600'}`}
                                                style={{ backgroundColor: c.hex }}
                                            >
                                                <span className={`text-lg font-bold ${c.id === 'W' ? 'text-gray-900' : 'text-white'}`}>{c.id}</span>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                                
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Image URL (Optional)</label>
                                    <input type="text" value={customTokenData.imageUrl} onChange={e => setCustomTokenData({...customTokenData, imageUrl: e.target.value})} className="w-full bg-gray-700 border border-gray-600 rounded p-2 text-white" placeholder="Leave empty to generate basic image" />
                                </div>
                                
                                <button onClick={createCustomToken} disabled={!customTokenData.name && !customTokenData.imageUrl} className="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-lg mt-4 disabled:bg-gray-600">
                                    Create Custom Token
                                </button>
                            </div>
                        )}
                    </Modal>

                    {/* Mulligan Summary Modal */}
                    {mulliganSummaryModal && (
                        <Modal isOpen={mulliganSummaryModal} onClose={() => {}} title="Mulligan Summary">
                            <div className="text-center space-y-4">
                                <p className="text-lg text-white">Starting Player: <span className="text-yellow-400 font-bold">{roomState.startingPlayer === user.uid ? 'You' : opponentName}</span></p>
                                <div className="flex justify-center gap-8">
                                    <div>
                                        <h4 className="text-blue-400 font-bold mb-2">Your Mulligans</h4>
                                        <p className="text-3xl font-bold">{myState.mulliganCount || 0}</p>
                                    </div>
                                    <div>
                                        <h4 className="text-red-400 font-bold mb-2">{opponentName}'s Mulligans</h4>
                                        <p className="text-3xl font-bold">{opponentState.mulliganCount || 0}</p>
                                    </div>
                                </div>
                                <p className="text-sm text-gray-400">Confirm to start the game.</p>
                                <button onClick={confirmMulliganSummary} className="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-6 rounded-lg">Confirm</button>
                            </div>
                        </Modal>
                    )}

                    {/* End Game / Result Modal */}
                    {leaveGameModal && (
                        <Modal isOpen={leaveGameModal} onClose={() => setLeaveGameModal(false)} title="End Game">
                            {gameResult.winner ? (
                                <div className="text-center space-y-4">
                                    <p className="text-xl font-bold text-yellow-400">Game Result Submitted!</p>
                                    <p className="text-lg text-white">Winner: <span className="text-green-400 font-bold">{gameResult.winner === user.uid ? 'You' : opponentName}</span></p>
                                    <p className="text-sm text-gray-400">
                                        {gameResult.confirmed ? 
                                            "Result confirmed by both players. You can safely leave." : 
                                            gameResult.submittedBy === user.uid ? "Waiting for opponent's confirmation." : "Your opponent has submitted this result. Please confirm or dispute."
                                        }
                                    </p>
                                    <div className="flex justify-center gap-4">
                                        {gameResult.submittedBy !== user.uid && !gameResult.confirmed && (
                                            <button onClick={confirmGameResult} className="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-6 rounded-lg">Confirm Result</button>
                                        )}
                                        {gameResult.submittedBy !== user.uid && !gameResult.confirmed && (
                                            <button onClick={disputeGameResult} className="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-6 rounded-lg">Dispute</button>
                                        )}
                                        {(gameResult.confirmed || gameResult.submittedBy === user.uid) && (
                                            <button onClick={onLeave} className="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-6 rounded-lg">Leave Game</button>
                                        )}
                                    </div>
                                </div>
                            ) : (
                                <div className="text-center space-y-4">
                                    <p className="text-xl font-bold text-white mb-4">Who won the game?</p>
                                    <div className="flex justify-center gap-4">
                                        <button onClick={() => submitGameResult(user.uid)} className="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg">I Won</button>
                                        <button onClick={() => submitGameResult(opponentId)} className="bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-8 rounded-lg">{opponentName} Won</button>
                                    </div>
                                    <button onClick={onLeave} className="text-gray-400 hover:text-white mt-4">Just Leave (No Result Tracking)</button>
                                </div>
                            )}
                        </Modal>
                    )}

                    {/* Card Hover View */}
                    {hoveredCard && 
                        <div className="fixed top-20 right-4 z-[100] pointer-events-none w-64 h-[350px] rounded-xl overflow-hidden shadow-2xl border-2 border-yellow-500 bg-black">
                            <img src={hoveredCard} className="w-full h-full object-contain" />
                        </div>
                    }

                    {/* Library Context Menu */}
                    {libraryMenu && 
                        <ContextMenu 
                            x={libraryMenu.x} 
                            y={libraryMenu.y} 
                            onClose={() => setLibraryMenu(null)} 
                            options={[
                                { label: 'Draw Card', action: drawCard },
                                { label: 'Look at Top Card', action: () => { if(myState.library.length>0) setTopCardView(myState.library[0]); } },
                                { label: 'Shuffle Library', action: shuffleLibrary },
                                { label: 'View Entire Library', action: () => setViewingZone('library') }
                            ]} 
                        /> 
                    }

                    {/* Card Context Menu */}
                    {cardContextMenu && 
                        <ContextMenu 
                            x={cardContextMenu.x} 
                            y={cardContextMenu.y} 
                            onClose={() => setCardContextMenu(null)} 
                            options={cardContextMenu.options} 
                        />
                    }

                    {/* Top Card View Modal */}
                    {topCardView && 
                        <Modal isOpen={true} onClose={() => setTopCardView(null)} title="Top of Library">
                            <div className="flex flex-col items-center gap-4">
                                <img src={topCardView.image_url} className="w-48 rounded-xl shadow-lg" />
                                <div className="flex gap-4">
                                    <button onClick={() => { setTopCardView(null); }} className="bg-blue-600 px-4 py-2 rounded text-white">Keep on Top</button>
                                    <button onClick={() => { moveCardToZone(topCardView, 'library_bottom'); setTopCardView(null); }} className="bg-yellow-600 px-4 py-2 rounded text-white">Put on Bottom</button>
                                    <button onClick={() => { playCard(topCardView, 'library_top', 'lower'); setTopCardView(null); }} className="bg-green-600 px-4 py-2 rounded text-white">Play</button>
                                </div>
                            </div>
                        </Modal>
                    }

                    {/* Zone Viewer Modal */}
                    {viewingZone && 
                        <Modal isOpen={true} onClose={() => setViewingZone(null)} title={`Viewing ${viewingZone.charAt(0).toUpperCase() + viewingZone.slice(1)}`}>
                            <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 xl:grid-cols-8 gap-4">
                                {(myState[viewingZone] || []).map(card => (
                                    <div key={card.instanceId} className="flex flex-col items-center group relative">
                                        <div 
                                            className="cursor-pointer"
                                            draggable 
                                            onDragStart={(e) => handleDragStart(e, card, viewingZone)}
                                        >
                                            <CardImage 
                                                src={card.image_url} 
                                                className="w-full rounded card-shadow" 
                                                onMouseEnter={() => setHoveredCard(card.image_url)} 
                                                onMouseLeave={() => setHoveredCard(null)} 
                                            />
                                        </div>
                                        <div className="absolute top-0 right-0 m-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                            <button onClick={() => playCard(card, viewingZone, 'lower')} title="Play to Battlefield" className="bg-green-600 text-white p-1 rounded-full"><i data-lucide="play" className="w-4 h-4"></i></button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                            {viewingZone === 'library' && myState.library.length > 0 && (
                                <div className="mt-4 flex justify-center">
                                    <button onClick={() => { const newLib = [...myState.library]; for (let i = newLib.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newLib[i], newLib[j]] = [newLib[j], newLib[i]]; } updateMyState({ library: newLib }); }} className="bg-purple-600 hover:bg-purple-500 text-white px-4 py-2 rounded font-bold">Shuffle Library</button>
                                </div>
                            )}
                        </Modal>
                    }
                </div>
            );
        };
        
        // --- DECK MANAGER / LOBBY (Simplified as the user only asked for Arena) ---
        // (Assuming DeckManager and Lobby are similar to the updated version to allow GameSim to work)
        const DeckManager = ({ user, onSelectDeck }) => {
            const [decks, setDecks] = useState([]);
            const [loading, setLoading] = useState(true);
            const [searchQuery, setSearchQuery] = useState('');

            useEffect(() => {
                const loadDecks = async () => {
                    const deckCollection = window.collection(window.db, 'users', user.uid, 'decks');
                    const snapshot = await window.getDocs(deckCollection);
                    setDecks(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
                    setLoading(false);
                };
                loadDecks();
            }, [user.uid]);
            
            const filteredDecks = decks.filter(d => d.name.toLowerCase().includes(searchQuery.toLowerCase()));

            if (loading) return <div className="h-full flex items-center justify-center text-yellow-400"><div className="loader"></div><p className="ml-2">Loading Decks...</p></div>;

            return (
                <div className="p-8 max-w-7xl mx-auto">
                    <h2 className="text-3xl font-bold text-yellow-400 mb-6">Select Your Deck</h2>
                    <input type="text" placeholder="Search Decks..." value={searchQuery} onChange={e => setSearchQuery(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded p-3 text-white mb-6" />
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {filteredDecks.length > 0 ? filteredDecks.map(deck => (
                            <div key={deck.id} onClick={() => onSelectDeck(deck)} className="bg-gray-800 p-6 rounded-xl border border-gray-700 hover:border-yellow-500 transition-all cursor-pointer shadow-lg">
                                <h3 className="text-xl font-bold text-white mb-2">{deck.name}</h3>
                                <p className="text-gray-400 text-sm">{deck.commander ? `Commander: ${deck.commander.name}` : 'No Commander'}</p>
                                <p className="text-gray-400 text-sm mt-1">{deck.cards.length} cards in deck</p>
                                <div className="mt-4 flex gap-2">
                                    {deck.colors.map(c => <span key={c} className={`w-6 h-6 rounded-full border-2 border-gray-900 flex items-center justify-center text-xs font-bold`} style={{ backgroundColor: COLOR_DATA.find(cd => cd.id === c)?.hex }}></span>)}
                                </div>
                            </div>
                        )) : (
                            <p className="text-gray-500">No decks found. Go to the Deck Builder to create one.</p>
                        )}
                    </div>
                </div>
            );
        };
        
        const Lobby = ({ user, selectedDeck, onSelectDeck, onStartGame, onLeaveGame }) => {
            const [rooms, setRooms] = useState([]);
            const [creating, setCreating] = useState(false);
            const [loading, setLoading] = useState(true);

            // Fetch rooms
            useEffect(() => {
                const q = window.query(window.getPublicRoomCollection());
                const unsubscribe = window.onSnapshot(q, (snapshot) => {
                    const roomList = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setRooms(roomList.filter(r => r.players.length < 2 || r.players.includes(user.uid)));
                    setLoading(false);
                });
                return () => unsubscribe();
            }, [user.uid]);
            
            const createRoom = async () => {
                if (!selectedDeck) return;
                setCreating(true);
                try {
                    const newRoomRef = await window.addDoc(window.getPublicRoomCollection(), {
                        host: user.uid,
                        hostName: user.displayName || user.email.split('@')[0],
                        players: [user.uid],
                        deck: { [user.uid]: selectedDeck },
                        createdAt: window.Timestamp.now(),
                        gameState: {}, // Will be initialized by GameSim
                        startingPlayer: null,
                        currentTurn: null,
                        phase: null,
                        gameResult: null,
                        emptyAt: null
                    });
                    onStartGame(newRoomRef.id);
                } catch (error) {
                    console.error("Error creating room:", error);
                    alert("Fehler beim Erstellen des Raums. Bitte versuchen Sie es erneut.");
                } finally {
                    setCreating(false);
                }
            };
            
            const joinRoom = async (roomId) => {
                if (!selectedDeck) return;
                try {
                    const roomRef = window.doc(window.getPublicRoomCollection(), roomId);
                    await window.updateDoc(roomRef, { 
                        players: window.arrayUnion(user.uid),
                        [`deck.${user.uid}`]: selectedDeck
                    });
                    onStartGame(roomId);
                } catch (error) {
                    console.error("Error joining room:", error);
                    alert("Fehler beim Beitreten des Raums. Bitte versuchen Sie es erneut.");
                }
            };

            const deleteRoom = async (roomId, e) => {
                e.stopPropagation();
                if(!confirm("Delete room?")) return;
                await window.deleteDoc(window.doc(window.getPublicRoomCollection(), roomId));
            };

            const clearMyRooms = async () => {
                if(!confirm("Close ALL your rooms?")) return;
                const q = window.query(window.getPublicRoomCollection(), window.where('host', '==', user.uid));
                const snapshot = await window.getDocs(q);
                snapshot.forEach(async (docSnap) => await window.deleteDoc(docSnap.ref));
            };
            
            const RoomTimer = ({ emptyAt }) => { 
                const [timeLeft, setTimeLeft] = useState(0); 
                useEffect(() => { 
                    if (!emptyAt) return; 
                    const updateTimer = () => { const remaining = Math.max(0, emptyAt - Date.now()); setTimeLeft(remaining); }; 
                    updateTimer(); const interval = setInterval(updateTimer, 1000); return () => clearInterval(interval); 
                }, [emptyAt]); 
                if (!emptyAt) return null; 
                const seconds = Math.floor(timeLeft / 1000); 
                const minutes = Math.floor(seconds / 60); 
                const remainingSeconds = seconds % 60; 
                const isWarning = timeLeft < 60000; 
                return <div className={`text-xs ${isWarning ? 'text-red-400 timer-warning' : 'text-gray-400'}`}> {minutes}:{remainingSeconds.toString().padStart(2, '0')}</div>; 
            }; 

            return (
                <div className="p-8 max-w-7xl mx-auto h-full overflow-y-auto">
                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div className="lg:col-span-1">
                            <h2 className="text-2xl font-bold text-yellow-400 mb-4">Your Deck</h2>
                            {selectedDeck ? (
                                <div className="bg-gray-800 p-6 rounded-xl border border-yellow-500 shadow-xl">
                                    <h3 className="text-xl font-bold text-white mb-2">{selectedDeck.name}</h3>
                                    <p className="text-gray-400 text-sm">{selectedDeck.commander ? `Commander: ${selectedDeck.commander.name}` : 'No Commander'}</p>
                                    <p className="text-gray-400 text-sm mt-1">{selectedDeck.cards.length} cards in deck</p>
                                    <div className="mt-4 flex gap-2">
                                        {selectedDeck.colors.map(c => <span key={c} className={`w-6 h-6 rounded-full border-2 border-gray-900 flex items-center justify-center text-xs font-bold`} style={{ backgroundColor: COLOR_DATA.find(cd => cd.id === c)?.hex }}></span>)}
                                    </div>
                                    <button onClick={() => onSelectDeck(null)} className="mt-4 text-sm text-red-400 hover:text-red-300">Change Deck</button>
                                </div>
                            ) : (
                                <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 text-center">
                                    <p className="text-gray-400 mb-3">No deck selected.</p>
                                    <button onClick={() => onSelectDeck('open_manager')} className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded">Select Deck</button>
                                </div>
                            )}

                             <button 
                                onClick={createRoom} 
                                disabled={!selectedDeck || creating} 
                                className="mt-6 w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-lg flex items-center justify-center disabled:bg-gray-600"
                            >
                                {creating ? <div className="loader mr-2 w-5 h-5"></div> : <i data-lucide="plus" className="w-5 h-5 mr-2"></i>}
                                {creating ? 'Creating Room...' : 'Create New Game Room'}
                            </button>
                             <button 
                                onClick={clearMyRooms} 
                                className="mt-2 w-full text-red-400 hover:text-red-300 text-sm py-2 rounded-lg border border-red-400/50 hover:border-red-400 transition-colors"
                            >
                                Close All My Rooms
                            </button>
                        </div>

                        <div className="lg:col-span-2">
                            <h2 className="text-2xl font-bold text-yellow-400 mb-4">Available Rooms</h2>
                            <div className="space-y-2">
                                {rooms.filter(r => r.players.length < 2).map(room => (
                                    <div key={room.id} className={`bg-gray-800 p-4 rounded-lg border ${room.emptyAt ? 'border-red-500/50 bg-red-900/10' : 'border-gray-700'}`}>
                                        <div className="flex justify-between items-center">
                                            <div>
                                                <h3 className="font-bold text-white">{room.hostName}'s Room</h3>
                                                {room.emptyAt ? (
                                                    <div className="flex items-center space-x-2 mt-1">
                                                        <span className="text-red-400 text-sm font-bold">Closing:</span>
                                                        <RoomTimer emptyAt={room.emptyAt} />
                                                    </div>
                                                ) : (
                                                    <p className="text-sm text-gray-400">{room.players.length}/2 players</p>
                                                )}
                                            </div>
                                            {room.host === user.uid ? (
                                                <button onClick={(e) => deleteRoom(room.id, e)} className="bg-red-600 hover:bg-red-500 text-white p-2 rounded" title="Delete my room">
                                                    <i data-lucide="trash" className="w-5 h-5"></i>
                                                </button>
                                            ) : (
                                                <button 
                                                    onClick={() => joinRoom(room.id)}
                                                    disabled={!selectedDeck || !!room.emptyAt}
                                                    className="bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-4 py-2 rounded"
                                                >
                                                    {room.emptyAt ? 'Closing' : 'Join'}
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                ))}
                                {rooms.filter(r => r.players.length < 2).length === 0 && (
                                    <p className="text-gray-500 text-center py-8">No rooms available</p>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const App = ({ user }) => {
            const [view, setView] = useState('lobby'); // 'lobby', 'deck_manager', 'game'
            const [selectedDeck, setSelectedDeck] = useState(null);
            const [decks, setDecks] = useState([]);
            const [rooms, setRooms] = useState([]);
            const [currentRoomId, setCurrentRoomId] = useState(null);

            useEffect(() => {
                // Load decks (simplified for this context)
                const loadDecks = async () => {
                    const deckCollection = window.collection(window.db, 'users', user.uid, 'decks');
                    const snapshot = await window.getDocs(deckCollection);
                    setDecks(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
                };
                loadDecks();
            }, [user.uid]);

            const handleSelectDeck = (deck) => {
                setSelectedDeck(deck);
                setView('lobby');
            };
            
            const handleStartGame = (roomId) => {
                setCurrentRoomId(roomId);
                setView('game');
            };

            const leaveGame = async () => {
                if (currentRoomId) {
                    const roomRef = window.doc(window.getPublicRoomCollection(), currentRoomId);
                    const roomSnap = await window.getDocs(window.query(window.getPublicRoomCollection(), window.where('__name__', '==', currentRoomId)));

                    if (!roomSnap.empty) {
                        const roomData = roomSnap.docs[0].data();
                        const remainingPlayers = roomData.players.filter(pId => pId !== user.uid);

                        if (remainingPlayers.length === 0) {
                            await window.deleteDoc(roomRef);
                        } else {
                            const twoMinutesFromNow = Date.now() + 120000;
                            await window.updateDoc(roomRef, { 
                                players: remainingPlayers,
                                emptyAt: twoMinutesFromNow
                            });
                        }
                    }
                    setCurrentRoomId(null);
                    setView('lobby');
                }
            };
            
            // Simplified rendering based on view state
            const renderContent = () => {
                if (view === 'deck_manager') {
                    return <DeckManager user={user} onSelectDeck={handleSelectDeck} />;
                }
                if (view === 'game' && currentRoomId && selectedDeck) {
                    return <GameSim deck={selectedDeck} onLeave={leaveGame} roomId={currentRoomId} />;
                }
                // Default to Lobby
                return <Lobby user={user} selectedDeck={selectedDeck} onSelectDeck={(action) => { if(action === 'open_manager') setView('deck_manager'); else setSelectedDeck(action); }} onStartGame={handleStartGame} onLeaveGame={leaveGame} />;
            };
            
            return (
                <div className="h-full flex flex-col">
                    <Header user={user} selectedDeck={selectedDeck} />
                    <div className="flex-grow overflow-hidden">
                        {renderContent()}
                    </div>
                </div>
            );
        };
        
        // --- LUCIDE ICON INITIALIZATION ---
        // This is necessary because Lucide icons are used throughout the React components
        useEffect(() => {
            lucide.createIcons();
        }, []);


        // Initial check is handled by module script
    </script>
</body>
</html>